    
    
    
    

    

    \hypertarget{series-de-pandas}{%
\section{\texorpdfstring{\texttt{Series} de
\texttt{pandas}}{Series de pandas}}\label{series-de-pandas}}

    \hypertarget{compluxe9ment---niveau-intermuxe9diaire}{%
\subsection{Complément - niveau
intermédiaire}\label{compluxe9ment---niveau-intermuxe9diaire}}

    \hypertarget{cruxe9ation-dune-series}{%
\subsubsection{\texorpdfstring{Création d'une
\texttt{Series}}{Création d'une Series}}\label{cruxe9ation-dune-series}}

    Un objet de type \texttt{Series} est un tableau \texttt{numpy} à une
dimension avec un index, par conséquent, une \texttt{Series} a une
certaine similarité avec un dictionnaire, et peut d'ailleurs être
directement construite à partir de ce dictionnaire. Notons que, comme
pour un dictionnaire, l'accès ou la modification est en \(O(1)\),
c'est-à-dire à temps constant indépendamment du nombre d'éléments dans
la \texttt{Series}.

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}1}]:} \PY{c+c1}{\PYZsh{} Regardons la construction d\PYZsq{}une Series}
        \PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}
        \PY{k+kn}{import} \PY{n+nn}{pandas} \PY{k}{as} \PY{n+nn}{pd}
        
        \PY{c+c1}{\PYZsh{} à partir d\PYZsq{}un itérable}
        \PY{n}{s} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{Series}\PY{p}{(}\PY{p}{[}\PY{n}{x}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2} \PY{k}{for} \PY{n}{x} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{)}\PY{p}{]}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{n}{s}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
0     0
1     1
2     4
3     9
4    16
5    25
6    36
7    49
8    64
9    81
dtype: int64
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}2}]:} \PY{c+c1}{\PYZsh{} en contrôlant maintenant le type}
        \PY{n}{s} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{Series}\PY{p}{(}\PY{p}{[}\PY{n}{x}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2} \PY{k}{for} \PY{n}{x} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{)}\PY{p}{]}\PY{p}{,} \PY{n}{dtype}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{int8}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{n}{s}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
0     0
1     1
2     4
3     9
4    16
5    25
6    36
7    49
8    64
9    81
dtype: int8
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}3}]:} \PY{c+c1}{\PYZsh{} en définissant un index, par défaut l\PYZsq{}index est un rang démarrant à 0}
        \PY{n}{s} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{Series}\PY{p}{(}\PY{p}{[}\PY{n}{x}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2} \PY{k}{for} \PY{n}{x} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{)}\PY{p}{]}\PY{p}{,}
                      \PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{n}{x} \PY{k}{for} \PY{n}{x} \PY{o+ow}{in} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{abcdefghij}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,}
                      \PY{n}{dtype}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{int8}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}
                     \PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{n}{s}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
a     0
b     1
c     4
d     9
e    16
f    25
g    36
h    49
i    64
j    81
dtype: int8
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}4}]:} \PY{c+c1}{\PYZsh{} et directement à partir d\PYZsq{}un dictionnaire,}
        \PY{c+c1}{\PYZsh{} les clefs forment l\PYZsq{}index}
        \PY{n}{d} \PY{o}{=} \PY{p}{\PYZob{}}\PY{n}{k}\PY{p}{:}\PY{n}{v}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2} \PY{k}{for} \PY{n}{k}\PY{p}{,} \PY{n}{v} \PY{o+ow}{in} \PY{n+nb}{zip}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{abcdefghij}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{)}\PY{p}{)}\PY{p}{\PYZcb{}}
        \PY{n+nb}{print}\PY{p}{(}\PY{n}{d}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
\{'a': 0, 'b': 1, 'c': 4, 'd': 9, 'e': 16, 'f': 25, 'g': 36, 'h': 49, 'i': 64, 'j': 81\}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}5}]:} \PY{n}{s} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{Series}\PY{p}{(}\PY{n}{d}\PY{p}{,} \PY{n}{dtype}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{int8}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{n}{s}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
a     0
b     1
c     4
d     9
e    16
f    25
g    36
h    49
i    64
j    81
dtype: int8
\end{Verbatim}

    Évidemment, l'intérêt d'un index est de pouvoir accéder à un élément par
son index, comme nous aurons l'occasion de le revoir~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}6}]:} \PY{n+nb}{print}\PY{p}{(}\PY{n}{s}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{f}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
25
\end{Verbatim}

    \hypertarget{index}{%
\subsubsection{Index}\label{index}}

    L'index d'une \texttt{Series} est un objet implémenté sous la forme d'un
\texttt{ndarray} de \texttt{numpy}, mais qui ne peut contenir que des
objets hashables (pour garantir la performance de l'accès).

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}7}]:} \PY{c+c1}{\PYZsh{} pour accéder à l\PYZsq{}index d\PYZsq{}un objet Series}
        \PY{c+c1}{\PYZsh{} attention, index est un attribut, pas une fonction}
        \PY{n+nb}{print}\PY{p}{(}\PY{n}{s}\PY{o}{.}\PY{n}{index}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
Index(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'], dtype='object')
\end{Verbatim}

    L'index va également supporter un certain nombre de méthodes qui vont
faciliter son utilisation. Pour plus de détails, voyez
\href{http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Index.html\#pandas.Index}{la
documentation de l'objet Index} et de ses sous-classes.

    L'autre moitié de l'objet \texttt{Series} est accessible via l'attribut
\texttt{values}. \textbf{ATTENTION} à nouveau ici, c'est un
\textbf{attribut} de l'objet et non pas une méthode, ce qui est très
troublant par rapport à l'interface d'un dictionnaire.

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}8}]:} \PY{c+c1}{\PYZsh{} regardons les valeurs de ma Series}
        \PY{c+c1}{\PYZsh{} ATTENTION !! values est un attribut, pas une fonction}
        \PY{n+nb}{print}\PY{p}{(}\PY{n}{s}\PY{o}{.}\PY{n}{values}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
[ 0  1  4  9 16 25 36 49 64 81]
\end{Verbatim}

    Mais une \texttt{Series} a également une interface de dictionnaire à
laquelle on accède de la manière suivante~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}9}]:} \PY{c+c1}{\PYZsh{} les clefs correspondent à l\PYZsq{}index}
        \PY{n}{k} \PY{o}{=} \PY{n}{s}\PY{o}{.}\PY{n}{keys}\PY{p}{(}\PY{p}{)} \PY{c+c1}{\PYZsh{} attention ici c\PYZsq{}est un appel de fonction !}
        \PY{n+nb}{print}\PY{p}{(}\PY{n}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Les clefs: }\PY{l+s+si}{\PYZob{}k\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
Les clefs: Index(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'], dtype='object')
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}10}]:} \PY{c+c1}{\PYZsh{} et les couples (clefs, valeurs) sous forme d\PYZsq{}un objet zip}
         \PY{k}{for} \PY{n}{k}\PY{p}{,}\PY{n}{v} \PY{o+ow}{in} \PY{n}{s}\PY{o}{.}\PY{n}{items}\PY{p}{(}\PY{p}{)}\PY{p}{:} \PY{c+c1}{\PYZsh{} attention ici aussi c\PYZsq{}est un appel de fonction !}
             \PY{n+nb}{print}\PY{p}{(}\PY{n}{k}\PY{p}{,} \PY{n}{v}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
a 0
b 1
c 4
d 9
e 16
f 25
g 36
h 49
i 64
j 81
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}11}]:} \PY{c+c1}{\PYZsh{} pour finir remarquons que le test d\PYZsq{}appartenance est possible sur les index}
         \PY{n+nb}{print}\PY{p}{(}\PY{n}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Est\PYZhy{}ce que a est dans s ? }\PY{l+s+s2}{\PYZob{}}\PY{l+s+s2}{\PYZsq{}}\PY{l+s+s2}{a}\PY{l+s+s2}{\PYZsq{}}\PY{l+s+s2}{ in s\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
         \PY{n+nb}{print}\PY{p}{(}\PY{n}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Est\PYZhy{}ce que z est dans s ? }\PY{l+s+s2}{\PYZob{}}\PY{l+s+s2}{\PYZsq{}}\PY{l+s+s2}{z}\PY{l+s+s2}{\PYZsq{}}\PY{l+s+s2}{ in s\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
Est-ce que a est dans s ? True
Est-ce que z est dans s ? False
\end{Verbatim}

    Vous remarquez ici qu'alors que \texttt{values} et \texttt{index} sont
des attributs de la \texttt{Series}, \texttt{keys()} et \texttt{items()}
sont des méthodes. Voici un exemple des nombreuses petites incohérences
de \texttt{pandas} avec lesquelles il faut vivre.

    \hypertarget{piuxe8ges-uxe0-uxe9viter}{%
\subsubsection{Pièges à éviter}\label{piuxe8ges-uxe0-uxe9viter}}

    Avant d'aller plus loin, il faut faire attention à la gestion du type
des objets contenus dans notre \texttt{Series} (on aura le même problème
avec les \texttt{DataFrame}). Alors qu'un \texttt{ndarray} de
\texttt{numpy} a un type qui ne change pas, une \texttt{Series} peut
implicitement changer le type de ses valeurs lors d'opérations
d'affectations.

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}12}]:} \PY{c+c1}{\PYZsh{} créons une Series et regardons le type de ses valeurs}
         \PY{n}{s} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{Series}\PY{p}{(}\PY{p}{\PYZob{}}\PY{n}{k}\PY{p}{:}\PY{n}{v}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2} \PY{k}{for} \PY{n}{k}\PY{p}{,} \PY{n}{v} \PY{o+ow}{in} \PY{n+nb}{zip}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{abcdefghij}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{)}\PY{p}{)}\PY{p}{\PYZcb{}}\PY{p}{)}
         \PY{n+nb}{print}\PY{p}{(}\PY{n}{s}\PY{o}{.}\PY{n}{values}\PY{o}{.}\PY{n}{dtype}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
int64
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}13}]:} \PY{c+c1}{\PYZsh{} On a déjà vu que l\PYZsq{}on ne pouvait pas modifier lors d\PYZsq{}une affectation le}
         \PY{c+c1}{\PYZsh{} type d\PYZsq{}un ndarray numpy}
         
         \PY{k}{try}\PY{p}{:}
             \PY{n}{s}\PY{o}{.}\PY{n}{values}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{spam}\PY{l+s+s1}{\PYZsq{}}
         \PY{k}{except} \PY{n+ne}{ValueError} \PY{k}{as} \PY{n}{e}\PY{p}{:}
             \PY{n+nb}{print}\PY{p}{(}\PY{n}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{On ne peut pas affecter une str à un ndarray de int64:}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+si}{\PYZob{}e\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
On ne peut pas affecter une str à un ndarray de int64:
invalid literal for int() with base 10: 'spam'
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}14}]:} \PY{c+c1}{\PYZsh{} Par contre, on peut le faire sur une Series}
         \PY{n}{s}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{c}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{spam}\PY{l+s+s1}{\PYZsq{}}
         
         \PY{c+c1}{\PYZsh{} et maintenant le type des valeurs de la Series a changé}
         \PY{n+nb}{print}\PY{p}{(}\PY{n}{s}\PY{o}{.}\PY{n}{values}\PY{o}{.}\PY{n}{dtype}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
object
\end{Verbatim}

    C'est un point extrêment important puisque toutes les opérations
vectorisées vont avoir leur performance impactée et le résultat obtenu
peut même être faux. Regardons cela~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}15}]:} \PY{n}{s} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{Series}\PY{p}{(}\PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{10}\PY{n}{\PYZus{}000}\PY{p}{)}\PY{p}{)}
         \PY{n+nb}{print}\PY{p}{(}\PY{n}{s}\PY{o}{.}\PY{n}{values}\PY{o}{.}\PY{n}{dtype}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
int64
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}16}]:} \PY{c+c1}{\PYZsh{} combien de temps prend le calcul du carré des valeurs}
         \PY{o}{\PYZpc{}}\PY{k}{timeit} s**2
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
71.2 µs ± 687 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}17}]:} \PY{c+c1}{\PYZsh{} ajoutons \PYZsq{}spam\PYZsq{} à la fin de la Series}
         \PY{n}{s}\PY{p}{[}\PY{l+m+mi}{10}\PY{n}{\PYZus{}000}\PY{p}{]} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{spam}\PY{l+s+s1}{\PYZsq{}}
         
         \PY{c+c1}{\PYZsh{} oups, je me suis trompé, enlevons cet élément}
         \PY{k}{del} \PY{n}{s}\PY{p}{[}\PY{l+m+mi}{10}\PY{n}{\PYZus{}000}\PY{p}{]}
         
         \PY{c+c1}{\PYZsh{} calculons de nouveau le temps de calcul pour obtenir le carré des valeurs}
         \PY{o}{\PYZpc{}}\PY{k}{timeit} s**2
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
405 µs ± 41.5 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}18}]:} \PY{c+c1}{\PYZsh{} que se passe\PYZhy{}t\PYZhy{}il, pourquoi le calcul est maintenant plus long}
         \PY{n}{s}\PY{o}{.}\PY{n}{values}\PY{o}{.}\PY{n}{dtype}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}18}]:} dtype('O')
\end{Verbatim}
            
    Maintenant, les opérations vectorisées le sont sur des objets Python et
non plus sur des int64, il y a donc un impact sur la performance.

Et on peut même obtenir un résultat carrément faux. Regardons cela~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}19}]:} \PY{c+c1}{\PYZsh{} créons une series de trois entiers}
         \PY{n}{s} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{Series}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{]}\PY{p}{)}
         \PY{n+nb}{print}\PY{p}{(}\PY{n}{s}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
0    1
1    2
2    3
dtype: int64
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}20}]:} \PY{c+c1}{\PYZsh{} puis ajoutons un nouvel élément, mais ici je me trompe, c\PYZsq{}est une str}
         \PY{c+c1}{\PYZsh{} au lieu d\PYZsq{}un entier}
         \PY{n}{s}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{]} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{4}\PY{l+s+s1}{\PYZsq{}}
         
         \PY{c+c1}{\PYZsh{} à part le type qui pourrait attirer mon attention, rien dans l\PYZsq{}affichage}
         \PY{c+c1}{\PYZsh{} ne distingue les entiers de la str, à part le dtype}
         \PY{n+nb}{print}\PY{p}{(}\PY{n}{s}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
0    1
1    2
2    3
3    4
dtype: object
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}21}]:} \PY{c+c1}{\PYZsh{} seulement si j\PYZsq{}additionne, les entiers sont additionnés,}
         \PY{c+c1}{\PYZsh{} mais les chaînes de caractères concaténées.}
         \PY{n+nb}{print}\PY{p}{(}\PY{n}{s}\PY{o}{+}\PY{n}{s}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
0     2
1     4
2     6
3    44
dtype: object
\end{Verbatim}

    \hypertarget{alignement-dindex}{%
\subsubsection{Alignement d'index}\label{alignement-dindex}}

    Un intérêt majeur de \texttt{pandas} est de faire de l'alignement
d'index sur les objets que l'on manipule. Regardons un exemple~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}22}]:} \PY{n}{argent\PYZus{}poche\PYZus{}janvier} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{Series}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{30}\PY{p}{,} \PY{l+m+mi}{35}\PY{p}{,} \PY{l+m+mi}{20}\PY{p}{]}\PY{p}{,}
                                          \PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{alice}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{bob}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{julie}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
         \PY{n}{argent\PYZus{}poche\PYZus{}février} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{Series}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{30}\PY{p}{,} \PY{l+m+mi}{35}\PY{p}{,} \PY{l+m+mi}{20}\PY{p}{]}\PY{p}{,}
                                          \PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{alice}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{julie}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{sonia}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
         \PY{n}{argent\PYZus{}poche\PYZus{}janvier} \PY{o}{+} \PY{n}{argent\PYZus{}poche\PYZus{}février}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}22}]:} alice    60.0
         bob       NaN
         julie    55.0
         sonia     NaN
         dtype: float64
\end{Verbatim}
            
    On voit que les deux \texttt{Series} ont bien été alignées, mais on a un
problème. Lorsqu'une valeur n'est pas définie, elle vaut \texttt{NaN} et
si on ajoute \texttt{NaN} à une autre valeur, le résultat est
\texttt{NaN}. On peut corriger ce problème avec un appel explicite de la
fonction add qui accepte un argument \texttt{fill\_value} qui sera la
valeur par défaut en cas d'absence d'une valeur lors de l'opération.

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}23}]:} \PY{n}{argent\PYZus{}poche\PYZus{}janvier}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{argent\PYZus{}poche\PYZus{}février}\PY{p}{,} \PY{n}{fill\PYZus{}value}\PY{o}{=}\PY{l+m+mi}{0}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}23}]:} alice    60.0
         bob      35.0
         julie    55.0
         sonia    20.0
         dtype: float64
\end{Verbatim}
            
    \hypertarget{accuxe9s-aux-uxe9luxe9ments-dune-series}{%
\subsubsection{\texorpdfstring{Accés aux éléments d'une
\texttt{Series}}{Accés aux éléments d'une Series}}\label{accuxe9s-aux-uxe9luxe9ments-dune-series}}

    Comme les \texttt{Series} sont basées sur des \texttt{ndarray} de
\texttt{numpy}, elles supportent les opérations d'accès aux éléments des
\texttt{ndarray}, notamment la notion de masque et les broadcasts, tout
ça en conservant évidemment les index.

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}24}]:} \PY{n}{s} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{Series}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{30}\PY{p}{,} \PY{l+m+mi}{35}\PY{p}{,} \PY{l+m+mi}{20}\PY{p}{]}\PY{p}{,} \PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{alice}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{bob}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{julie}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} qui a plus de 25 ans}
         \PY{n+nb}{print}\PY{p}{(}\PY{n}{s}\PY{p}{[}\PY{n}{s}\PY{o}{\PYZgt{}}\PY{l+m+mi}{25}\PY{p}{]}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
alice    30
bob      35
dtype: int64
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}25}]:} \PY{c+c1}{\PYZsh{} regardons uniquement \PYZsq{}alice\PYZsq{} et \PYZsq{}julie\PYZsq{}}
         \PY{n+nb}{print}\PY{p}{(}\PY{n}{s}\PY{p}{[}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{alice}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{julie}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{]}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
alice    30
julie    20
dtype: int64
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}26}]:} \PY{c+c1}{\PYZsh{} et affectons sur un masque}
         \PY{n}{s}\PY{p}{[}\PY{n}{s}\PY{o}{\PYZlt{}}\PY{o}{=}\PY{l+m+mi}{25}\PY{p}{]} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{NaN}
         \PY{n+nb}{print}\PY{p}{(}\PY{n}{s}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
alice    30.0
bob      35.0
julie     NaN
dtype: float64
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}27}]:} \PY{c+c1}{\PYZsh{} notons également, que naturellement les opérations de broadcast}
         \PY{c+c1}{\PYZsh{} sont supportées}
         \PY{n}{s} \PY{o}{=} \PY{n}{s} \PY{o}{+} \PY{l+m+mi}{10}
         \PY{n+nb}{print}\PY{p}{(}\PY{n}{s}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
alice    40.0
bob      45.0
julie     NaN
dtype: float64
\end{Verbatim}

    \hypertarget{slicing-sur-les-series}{%
\subsubsection{\texorpdfstring{Slicing sur les
\texttt{Series}}{Slicing sur les Series}}\label{slicing-sur-les-series}}

    L'opération de slicing sur les \texttt{Series} est une source fréquente
d'erreur qui peut passer inaperçue pour les raisons suivantes~:

\begin{itemize}
\tightlist
\item
  on peut slicer sur les labels des index, mais aussi sur la position
  (l'indice) d'un élément dans la \texttt{Series}~;
\item
  les opérations de slices sur les positions et les labels se comportent
  différemment,
  \href{http://pandas.pydata.org/pandas-docs/stable/gotchas.html\#endpoints-are-inclusive}{un
  slice sur les positions exclut la borne de droite (comme tous les
  slices en Python), mais un slice sur un label inclut la borne de
  droite}~;
\item
  il peut y avoir ambiguïté entre un label et la position d'un élément
  lorsque le label est un entier.
\end{itemize}

Nous allons détailler chacun de ces cas, mais sachez qu'il existe une
solution qui évite toute ambiguïté, c'est d'utiliser les interfaces
\texttt{loc} et \texttt{iloc} que nous verrons un peu plus loin.

Regardons maintenant ces différents problèmes~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}28}]:} \PY{n}{s} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{Series}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{30}\PY{p}{,} \PY{l+m+mi}{35}\PY{p}{,} \PY{l+m+mi}{20}\PY{p}{,} \PY{l+m+mi}{28}\PY{p}{]}\PY{p}{,} \PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{alice}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{bob}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{julie}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{sonia}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
         \PY{n+nb}{print}\PY{p}{(}\PY{n}{s}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
alice    30
bob      35
julie    20
sonia    28
dtype: int64
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}29}]:} \PY{c+c1}{\PYZsh{} on peut accéder directement à la valeur correspondant à alice}
         \PY{n+nb}{print}\PY{p}{(}\PY{n}{s}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{alice}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} mais aussi par la position d\PYZsq{}alice dans l\PYZsq{}index}
         \PY{n+nb}{print}\PY{p}{(}\PY{n}{s}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
30
30
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}30}]:} \PY{c+c1}{\PYZsh{} On peut faire un slice sur les labels, dans ce cas la borne}
         \PY{c+c1}{\PYZsh{} de droite est incluse}
         \PY{n}{s}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{alice}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{julie}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}30}]:} alice    30
         bob      35
         julie    20
         dtype: int64
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}31}]:} \PY{c+c1}{\PYZsh{} et on peut faire un slice sur les positions, mais dans ce cas}
         \PY{c+c1}{\PYZsh{} la borne de droite est exclue, comme un slice normal en Python}
         \PY{n}{s}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{:}\PY{l+m+mi}{2}\PY{p}{]}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}31}]:} alice    30
         bob      35
         dtype: int64
\end{Verbatim}
            
    Ce comportement mérite quelques explications. On voit bien qu'exclure la
borne de droite peut se comprendre sur une position (si on exclut
\texttt{i} on prend \texttt{i-1}), par contre, c'est mal défini pour un
label.

En effet, l'ordre d'un index est défini au moment de sa création et le
label venant juste avant un autre label \texttt{L} ne peut pas être
trouvé uniquement avec la connaissance de \texttt{L}.

C'est pour cette raison que les concepteurs de \texttt{pandas} ont
préféré inclure la borne de droite.

Regardons maintenant plus en détail cette notion d'ordre sur les index.

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}32}]:} \PY{c+c1}{\PYZsh{} Regardons le slice sur un index avec un ordre particulier}
         \PY{n}{s} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{Series}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{30}\PY{p}{,} \PY{l+m+mi}{35}\PY{p}{,} \PY{l+m+mi}{20}\PY{p}{,} \PY{l+m+mi}{28}\PY{p}{]}\PY{p}{,} \PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{alice}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{bob}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{julie}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{sonia}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
         \PY{n+nb}{print}\PY{p}{(}\PY{n}{s}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{alice}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{julie}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
alice    30
bob      35
julie    20
dtype: int64
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}33}]:} \PY{c+c1}{\PYZsh{} Si on change l\PYZsq{}ordre de l\PYZsq{}index, ça change la signification du slice}
         \PY{n}{s} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{Series}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{30}\PY{p}{,} \PY{l+m+mi}{35}\PY{p}{,} \PY{l+m+mi}{20}\PY{p}{,} \PY{l+m+mi}{28}\PY{p}{]}\PY{p}{,} \PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{alice}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{bob}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{sonia}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{julie}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
         \PY{n+nb}{print}\PY{p}{(}\PY{n}{s}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{alice}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{julie}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
alice    30
bob      35
sonia    20
julie    28
dtype: int64
\end{Verbatim}

    Vous devez peut-être vous demander si un slice sur l'index est toujours
défini. La réponse est non~! Pour qu'un slice soit défini sur un index,
il faut que
\href{https://pandas.pydata.org/pandas-docs/stable/advanced.html\#non-monotonic-indexes-require-exact-matches}{l'index
ait une croissance monotone ou qu'il n'y ait pas de label dans l'index
qui soit dupliqué.}

Donc la croissance monotonique n'est pas nécessaire tant qu'il n'y a pas
de duplication de labels. Regardons cela.

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}34}]:} \PY{c+c1}{\PYZsh{} mon index a des labels dupliqués, mais a une croissance monotonique}
         \PY{n}{s} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{Series}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{30}\PY{p}{,} \PY{l+m+mi}{35}\PY{p}{,} \PY{l+m+mi}{20}\PY{p}{,} \PY{l+m+mi}{12}\PY{p}{]}\PY{p}{,} \PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{a}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{a}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{b}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{c}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
         \PY{c+c1}{\PYZsh{} le slice est défini}
         \PY{n}{s}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{a}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{b}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}34}]:} a    30
         a    35
         b    20
         dtype: int64
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}35}]:} \PY{c+c1}{\PYZsh{} mon index a des labels dupliqués et n\PYZsq{}a pas de croissance monotonique}
         \PY{n}{s} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{Series}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{30}\PY{p}{,} \PY{l+m+mi}{35}\PY{p}{,} \PY{l+m+mi}{20}\PY{p}{,} \PY{l+m+mi}{12}\PY{p}{]}\PY{p}{,} \PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{a}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{b}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{c}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{a}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
         \PY{c+c1}{\PYZsh{} le slice n\PYZsq{}est plus défini}
         \PY{k}{try}\PY{p}{:}
             \PY{n}{s}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{a}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{b}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}
         \PY{k}{except} \PY{n+ne}{KeyError} \PY{k}{as} \PY{n}{e}\PY{p}{:}
             \PY{n+nb}{print}\PY{p}{(}\PY{n}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Je n}\PY{l+s+s2}{\PYZsq{}}\PY{l+s+s2}{arrive pas à extraire un slice :}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+si}{\PYZob{}e\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
Je n'arrive pas à extraire un slice :
"Cannot get left slice bound for non-unique label: 'a'"
\end{Verbatim}

    Pour finir sur les problèmes que l'on peut rencontrer avec les slices,
que se passe-t-il si on a un index qui a pour label des entiers~?

Lorsque l'on va faire un slice, il va y avoir ambiguïté entre la
position du label et le label lui-même. Dans ce cas, \texttt{pandas}
donne la priorité à la position, mais ce qui est troublant, c'est que
lorsqu'on accède à un seul élément en dehors d'un slice, \texttt{pandas}
donne la priorité à l'index.

Encore une petite incohérence~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}36}]:} \PY{n}{s} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{Series}\PY{p}{(}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{a}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{b}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{c}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,} \PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}
         \PY{n+nb}{print}\PY{p}{(}\PY{n}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Si on accède directement à un élément, priorité au label : }\PY{l+s+si}{\PYZob{}s[0]\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
         \PY{n+nb}{print}\PY{p}{(}\PY{n}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Si on calcule un slice, priorité à la position : }\PY{l+s+si}{\PYZob{}s[0:1]\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
Si on accède directement à un élément, priorité au label : b
Si on calcule un slice, priorité à la position : 2    a
dtype: object
\end{Verbatim}

    \hypertarget{loc-et-iloc}{%
\subsubsection{\texorpdfstring{\texttt{loc} et
\texttt{iloc}}{loc et iloc}}\label{loc-et-iloc}}

    La solution à tous ces problèmes est de dire explicitement ce que l'on
veut faire. On peut en effet dire explicitement si l'on veut utiliser
les labels ou les positions, c'est ce qu'on vous recommande de faire
pour éviter les comportements implicites.

Pour utiliser les labels il faut utiliser \texttt{s.loc{[}{]}} et pour
utiliser les positions if faut utiliser \texttt{s.iloc{[}{]}} (le
\texttt{i} est pour localisation implicite, c'est-à-dire la position).
Regardons cela~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}37}]:} \PY{n+nb}{print}\PY{p}{(}\PY{n}{s}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
2    a
0    b
1    c
dtype: object
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}38}]:} \PY{c+c1}{\PYZsh{} accès au label}
         \PY{n+nb}{print}\PY{p}{(}\PY{n}{s}\PY{o}{.}\PY{n}{loc}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
b
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}39}]:} \PY{c+c1}{\PYZsh{} accès à la position}
         \PY{n+nb}{print}\PY{p}{(}\PY{n}{s}\PY{o}{.}\PY{n}{iloc}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
a
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}40}]:} \PY{c+c1}{\PYZsh{} slice sur les labels, ATTENTION, il inclut la borne de droite}
         \PY{n+nb}{print}\PY{p}{(}\PY{n}{s}\PY{o}{.}\PY{n}{loc}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{:}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
2    a
0    b
dtype: object
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}41}]:} \PY{c+c1}{\PYZsh{} slice sur les positions, ATTENTION, il exclut la borne de droite}
         \PY{n+nb}{print}\PY{p}{(}\PY{n}{s}\PY{o}{.}\PY{n}{iloc}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{:}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
2    a
0    b
dtype: object
\end{Verbatim}

    Pour allez plus loin, vous pouvez lire la documentation officielle~:

http://pandas.pydata.org/pandas-docs/stable/indexing.html

    \hypertarget{conclusion}{%
\subsubsection{Conclusion}\label{conclusion}}

    Nous avons vu que les \texttt{Series} forment une extension des ndarray
de dimension 1, en leur ajoutant un index qui permet une plus grande
expressivité pour accéder aux éléments. Seulement cette expressivité
vient au prix de quelques subtilités (conversions implicites de type,
accès aux labels ou aux positions) qu'il faut maîtriser.

Nous verrons dans le prochain complément la notion de \texttt{DataFrame}
qui est sans doute la plus utile et la plus puissante structure de
données de \texttt{pandas}. Tous les pièges que nous avons vus pour les
\texttt{Series} sont valables pour les \texttt{DataFrames}.


    % Add a bibliography block to the postdoc
    
    
    
