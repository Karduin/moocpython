    
    
    
    

    

    \hypertarget{usage-avanuxe7uxe9s-de-import}{%
\section{\texorpdfstring{Usage avançés de
\texttt{import}}{Usage avançés de import}}\label{usage-avanuxe7uxe9s-de-import}}

    \hypertarget{compluxe9ment---niveau-avancuxe9}{%
\subsection{Complément - niveau
avancé}\label{compluxe9ment---niveau-avancuxe9}}

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}1}]:} \PY{c+c1}{\PYZsh{} notre utilitaire pour afficher le code des modules}
        \PY{k+kn}{from} \PY{n+nn}{modtools} \PY{k}{import} \PY{n}{show\PYZus{}module}\PY{p}{,} \PY{n}{find\PYZus{}on\PYZus{}disk}
\end{Verbatim}


    \hypertarget{attributs-spuxe9ciaux}{%
\subsubsection{Attributs spéciaux}\label{attributs-spuxe9ciaux}}

    Les objets de type module possèdent des attributs spéciaux ; on les
reconnaît facilement car leur nom est en \emph{\texttt{\_\_truc\_\_}},
c'est une convention générale dans tous le langage~: on en a déjà vu
plusieurs exemples avec par exemple les méthodes
\texttt{\_\_iter\_\_()}.

    Voici pour commencer les attributs spéciaux les plus utilisées ; pour
cela nous reprenons le package d'un notebook précédent~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}2}]:} \PY{k+kn}{import} \PY{n+nn}{package\PYZus{}jouet}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
chargement du package package\_jouet
Chargement du module package\_jouet.module\_jouet dans le package 'package\_jouet'
\end{Verbatim}

    \hypertarget{name__}{%
\subparagraph{\texorpdfstring{\texttt{\_\_name\_\_}}{\_\_name\_\_}}\label{name__}}

    Le nom canonique du module~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}3}]:} \PY{n}{package\PYZus{}jouet}\PY{o}{.}\PY{n+nv+vm}{\PYZus{}\PYZus{}name\PYZus{}\PYZus{}}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}3}]:} 'package\_jouet'
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}4}]:} \PY{n}{package\PYZus{}jouet}\PY{o}{.}\PY{n}{module\PYZus{}jouet}\PY{o}{.}\PY{n+nv+vm}{\PYZus{}\PYZus{}name\PYZus{}\PYZus{}}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}4}]:} 'package\_jouet.module\_jouet'
\end{Verbatim}
            
    \hypertarget{file__}{%
\subparagraph{\texorpdfstring{\texttt{\_\_file\_\_}}{\_\_file\_\_}}\label{file__}}

    L'emplacement du fichier duquel a été chargé le module ; pour un package
ceci dénote un fichier \texttt{\_\_init\_\_.py}~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}5}]:} \PY{n}{package\PYZus{}jouet}\PY{o}{.}\PY{n+nv+vm}{\PYZus{}\PYZus{}file\PYZus{}\PYZus{}}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}5}]:} '/Users/tparment/git/flotpython/modules/package\_jouet/\_\_init\_\_.py'
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}6}]:} \PY{n}{package\PYZus{}jouet}\PY{o}{.}\PY{n}{module\PYZus{}jouet}\PY{o}{.}\PY{n+nv+vm}{\PYZus{}\PYZus{}file\PYZus{}\PYZus{}}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}6}]:} '/Users/tparment/git/flotpython/modules/package\_jouet/module\_jouet.py'
\end{Verbatim}
            
    \hypertarget{all__}{%
\subparagraph{\texorpdfstring{\texttt{\_\_all\_\_}}{\_\_all\_\_}}\label{all__}}

    Il est possible de redéfinir dans un module la variable
\texttt{\_\_all\_\_}, de façon à définir les symboles qui sont
réellement concernés par un \texttt{import\ *},
\href{https://docs.python.org/3/tutorial/modules.html\#importing-from-a-package}{comme
c'est décrit ici}.

Je rappelle toutefois que l'usage de \texttt{import\ *} est fortement
déconseillé dans du code de production.

    \hypertarget{import-absolu}{%
\subsubsection{Import absolu}\label{import-absolu}}

    La mécanique des imports telle qu'on l'a vue jusqu'ici est ce qui
s'appelle un \emph{import} absolu qui est depuis python-2.5 le mécanisme
par défaut : le module importé est systématiquement cherché à partir de
\texttt{sys.path}.

Dans ce mode de fonctionnement, si on trouve dans le même répertoire
deux fichiers \texttt{foo.py} et \texttt{bar.py}, et que dans le premier
on fait~:

\begin{Shaded}
\begin{Highlighting}[frame=lines,framerule=0.6mm,rulecolor=\color{asisframecolor}]
\ImportTok{import}\NormalTok{ bar}
\end{Highlighting}
\end{Shaded}

eh bien alors, malgré le fait qu'il existe ici même un fichier
\texttt{bar.py}, l'import ne réussit pas (sauf si le répertoire courant
est dans \texttt{sys.path}; en général ce n'est pas le cas).

    \hypertarget{import-relatif}{%
\subsubsection{Import relatif}\label{import-relatif}}

    Ce mécanisme d'import absolu a l'avantage d'éviter qu'un module local,
par exemple \texttt{random.py}, ne vienne cacher le module
\texttt{random} de la bibliothèque standard. Mais comment peut-on faire
alors pour charger le module \texttt{random.py} local ? C'est à cela que
sert l'import relatif.

Voyons cela sur un exemple~qui repose sur la hiérarchie suivante~:

\begin{Shaded}
\begin{Highlighting}[frame=lines,framerule=0.6mm,rulecolor=\color{asisframecolor}]
\ExtensionTok{package_relatif/}
                \ExtensionTok{__init__.py}\NormalTok{  (vide)}
                \ExtensionTok{main.py}
                \ExtensionTok{random.py}
\end{Highlighting}
\end{Shaded}

    Le fichier \texttt{\_\_init\_\_.py} ici est vide, et voici le code des
deux autres modules~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}7}]:} \PY{k+kn}{import} \PY{n+nn}{package\PYZus{}relatif}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}8}]:} \PY{c+c1}{\PYZsh{} le code de main.py}
        \PY{n}{code} \PY{o}{=} \PY{n}{find\PYZus{}on\PYZus{}disk}\PY{p}{(}\PY{n}{package\PYZus{}relatif}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{main.py}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
        \PY{o}{!}cat \PY{n+nv}{\PYZdl{}code}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]

\# pour importer un module entier en mode relatif
from . import random as local\_random\_module


\# la syntaxe pour importer seulement un symbole
from .random import alea


print(
    f"""On charge main.py
    \_\_name\_\_=\{\_\_name\_\_\}
    alea=\{alea()\}""")
\end{Verbatim}

    Nous avons illustré dans le point d'entrée \texttt{main.py} deux
exemples d'import relatif~:

    Les deux clauses \texttt{as} sont bien sûr optionnelles, on les utilise
ici uniquement pour bien identifier les différents objets en jeu.

    Le module local \texttt{random.py} expose une fonction \texttt{alea} qui
génére un string aléatoire en se basant sur le module standard
\texttt{random}~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}9}]:} \PY{c+c1}{\PYZsh{} le code de random.py}
        \PY{n}{code} \PY{o}{=} \PY{n}{find\PYZus{}on\PYZus{}disk}\PY{p}{(}\PY{n}{package\PYZus{}relatif}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{random.py}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
        \PY{o}{!}cat \PY{n+nv}{\PYZdl{}code}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
import random

print(f"On charge le module random local \{\_\_name\_\_\}")

def alea():
    return(f"[[\{random.randint(0, 10)\}]]")
\end{Verbatim}

    Cet exemple montre comment on peut importer un module local de nom
\texttt{random} \textbf{et} le module \texttt{random} qui provient de la
librairie standard~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}10}]:} \PY{k+kn}{import} \PY{n+nn}{package\PYZus{}relatif}\PY{n+nn}{.}\PY{n+nn}{main}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
On charge le module random local package\_relatif.random
On charge main.py
    \_\_name\_\_=package\_relatif.main
    alea=[[9]]
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}11}]:} \PY{n+nb}{print}\PY{p}{(}\PY{n}{package\PYZus{}relatif}\PY{o}{.}\PY{n}{main}\PY{o}{.}\PY{n}{alea}\PY{p}{(}\PY{p}{)}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
[[3]]
\end{Verbatim}

    \hypertarget{pour-remonter-dans-larborescence}{%
\subparagraph{Pour remonter dans
l'arborescence}\label{pour-remonter-dans-larborescence}}

    Il faut savoir également qu'on peut ``remonter'' dans l'arborescence de
fichiers en utilisant plusieurs points \texttt{.} consécutifs. Voici un
exemple fonctionnel, on part du même contenu que ci-dessus avec un
sous-package, comme ceci~:

    \begin{Shaded}
\begin{Highlighting}[frame=lines,framerule=0.6mm,rulecolor=\color{asisframecolor}]
\ExtensionTok{package_relatif/}
                \ExtensionTok{__init__.py}\NormalTok{      (vide)}
                \ExtensionTok{main.py}
                \ExtensionTok{random.py}
                \ExtensionTok{subpackage/}
                           \ExtensionTok{__init__.py}\NormalTok{  (vide)}
                           \ExtensionTok{submodule.py}
\end{Highlighting}
\end{Shaded}

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}12}]:} \PY{c+c1}{\PYZsh{} voyons le code de submodule:}
         \PY{k+kn}{import} \PY{n+nn}{package\PYZus{}relatif}\PY{n+nn}{.}\PY{n+nn}{subpackage}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}13}]:} \PY{c+c1}{\PYZsh{} le code de submodule/submodule.py}
         \PY{n}{code} \PY{o}{=} \PY{n}{find\PYZus{}on\PYZus{}disk}\PY{p}{(}\PY{n}{package\PYZus{}relatif}\PY{o}{.}\PY{n}{subpackage}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{submodule.py}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
         \PY{o}{!}cat \PY{n+nv}{\PYZdl{}code}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]

\# notez ici la présence des deux points pour remonter
from ..random import alea as imported

print(f"On charge \{\_\_name\_\_\}")

def alea():
    return f"<<\{imported()\}>>"
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}14}]:} \PY{k+kn}{import} \PY{n+nn}{package\PYZus{}relatif}\PY{n+nn}{.}\PY{n+nn}{subpackage}\PY{n+nn}{.}\PY{n+nn}{submodule}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
On charge package\_relatif.subpackage.submodule
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}15}]:} \PY{n+nb}{print}\PY{p}{(}\PY{n}{package\PYZus{}relatif}\PY{o}{.}\PY{n}{subpackage}\PY{o}{.}\PY{n}{submodule}\PY{o}{.}\PY{n}{alea}\PY{p}{(}\PY{p}{)}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
<<[[9]]>>
\end{Verbatim}

    \textbf{Ce qu'il faut retenir}

Sur cet exemple, on montre comment un import relatif permet à un module
d'importer un module local qui a le même nom qu'un module standard.

    \hypertarget{avantages-de-limport-relatif}{%
\subsubsection{Avantages de l'import
relatif}\label{avantages-de-limport-relatif}}

    Bien sûr ici on aurait pu faire

\begin{Shaded}
\begin{Highlighting}[frame=lines,framerule=0.6mm,rulecolor=\color{asisframecolor}]
\ImportTok{import}\NormalTok{ package_relatif.random}
\end{Highlighting}
\end{Shaded}

au lieu de

\begin{Shaded}
\begin{Highlighting}[frame=lines,framerule=0.6mm,rulecolor=\color{asisframecolor}]
\ImportTok{from}\NormalTok{ . }\ImportTok{import}\NormalTok{ random}
\end{Highlighting}
\end{Shaded}

    Mais l'import relatif présente notamment l'avantage d'être insensible
aux renommages divers à l'intérieur d'une bibliothèque.

    Dit autrement, lorsque deux modules sont situés dans le même répertoire,
il semble naturel que l'import entre eux se fasse par un import relatif,
plutôt que de devoir répéter \emph{ad nauseam} le nom de la bibliothèque
- ici \texttt{package\_relatif} - dans tous les imports.

    \hypertarget{frustrations-liuxe9es-uxe0-limport-relatif}{%
\subsubsection{Frustrations liées à l'import
relatif}\label{frustrations-liuxe9es-uxe0-limport-relatif}}

    \hypertarget{se-base-sur-__name__-et-non-sur-__file__}{%
\paragraph{\texorpdfstring{Se base sur \texttt{\_\_name\_\_} et non sur
\texttt{\_\_file\_\_}}{Se base sur \_\_name\_\_ et non sur \_\_file\_\_}}\label{se-base-sur-__name__-et-non-sur-__file__}}

    Toutefois, l'import relatif ne fonctionne pas toujours comme on pourrait
s'y attendre. Le point important à garder en tête est que lors d'un
import relatif, \textbf{c'est l'attribut \texttt{\_\_name\_\_}} qui sert
à déterminer le point de départ.

    Concrètement, lorsque dans \texttt{main.py} on fait~:

\begin{Shaded}
\begin{Highlighting}[frame=lines,framerule=0.6mm,rulecolor=\color{asisframecolor}]
\ImportTok{from}\NormalTok{ . }\ImportTok{import}\NormalTok{ random}
\end{Highlighting}
\end{Shaded}

l'interpréteur~:

\begin{itemize}
\tightlist
\item
  détermine que dans \texttt{main.py}, \texttt{\_\_name\_\_} vaut
  \texttt{package\_relatif.main};
\item
  il ``oublie'' le dernier morceau \texttt{main} pour calculer que le
  package courant est \texttt{package\_relatif}
\item
  et c'est ce nom qui sert à déterminer le point de départ de l'import
  relatif.
\end{itemize}

Aussi cet import est-il retranscrit en

\begin{Shaded}
\begin{Highlighting}[frame=lines,framerule=0.6mm,rulecolor=\color{asisframecolor}]
\ImportTok{from}\NormalTok{ package_relatif }\ImportTok{import}\NormalTok{ random}
\end{Highlighting}
\end{Shaded}

    De la même manière

\begin{Shaded}
\begin{Highlighting}[frame=lines,framerule=0.6mm,rulecolor=\color{asisframecolor}]
\ImportTok{from}\NormalTok{ .random }\ImportTok{import}\NormalTok{ run}
\end{Highlighting}
\end{Shaded}

devient

\begin{Shaded}
\begin{Highlighting}[frame=lines,framerule=0.6mm,rulecolor=\color{asisframecolor}]
\ImportTok{from}\NormalTok{ package_relatif.random }\ImportTok{import}\NormalTok{ run}
\end{Highlighting}
\end{Shaded}

    Par contre \textbf{l'attribut \texttt{\_\_file\_\_} n'est pas utilisé} :
ce n'est pas parce que deux fichiers python sont dans le même répertoire
que l'import relatif va toujours fonctionner. Avant de voir cela sur un
exemple, il nous faut revenir sur l'attribut \texttt{\_\_name\_\_}.

    \hypertarget{digression-sur-lattribut-__name__}{%
\paragraph{\texorpdfstring{Digression sur l'attribut
\texttt{\_\_name\_\_}}{Digression sur l'attribut \_\_name\_\_}}\label{digression-sur-lattribut-__name__}}

    Il faut savoir en effet que le \textbf{point d'entrée} du programme -
c'est-à-dire le fichier qui est passé directement à l'interpréteur
python - est considéré comme un module dont l'attribut
\texttt{\_\_name\_\_} vaut la chaîne \texttt{"\_\_main\_\_"}.

Concrètement, si vous faites

\begin{Shaded}
\begin{Highlighting}[frame=lines,framerule=0.6mm,rulecolor=\color{asisframecolor}]
\ExtensionTok{python3}\NormalTok{ tests/montest.py}
\end{Highlighting}
\end{Shaded}

alors la valeur observée dans l'attribut \texttt{\_\_name\_\_} n'est pas
\texttt{"tests.montest"}, mais la constante \texttt{"\_\_main\_\_"}.

    C'est pourquoi d'ailleurs
\href{https://docs.python.org/3/tutorial/modules.html\#executing-modules-as-scripts}{(et
c'est également expliqué ici)} vous trouverez parfois à la fin d'un
fichier source une phrase comme celle-ci~:

    \begin{Shaded}
\begin{Highlighting}[frame=lines,framerule=0.6mm,rulecolor=\color{asisframecolor}]
\ControlFlowTok{if} \VariableTok{__name__} \OperatorTok{==} \StringTok{"__main__"}\NormalTok{:}
    \OperatorTok{<}\NormalTok{faire vraiment quelque chose}\OperatorTok{>}
    \OperatorTok{<}\NormalTok{comme par exemple tester le module}\OperatorTok{>}
\end{Highlighting}
\end{Shaded}

    Cet idiome très répandu permet d'insérer à la fin d'un module du code -
souvent un code de test - qui~:

\begin{itemize}
\tightlist
\item
  va être exécuté quand on le passe directement à l'interpréteur python,
  mais
\item
  qui n'\textbf{est pas exécuté} lorsqu'on importe le module.
\end{itemize}

    \hypertarget{lattribut-__package__}{%
\paragraph{\texorpdfstring{L'attribut
\texttt{\_\_package\_\_}}{L'attribut \_\_package\_\_}}\label{lattribut-__package__}}

    Pour résumer~:

\begin{itemize}
\tightlist
\item
  le point d'entrée - celui qui est donné à \texttt{python} sur la ligne
  de commande - voit comme valeur pour \texttt{\_\_name\_\_} la
  constante \texttt{"\_\_main\_\_"},
\item
  et le mécanisme d'import relatif se base sur \texttt{\_\_name\_\_}
  pour localiser les modules importés.
\end{itemize}

    Du coup, par construction, il n'est quasiment pas possible d'utiliser
les imports relatifs à partir du script de lancement.

Pour pallier à ce type d'inconvénients, il a été introduit ultérieurment
(voir PEP 366 ci-dessous) la possibilité pour un module de définir
(écrire) l'attribut \texttt{\_\_package\_\_}, pour contourner cette
difficulté.

    \hypertarget{ce-quil-faut-retenir}{%
\paragraph{Ce qu'il faut retenir}\label{ce-quil-faut-retenir}}

    On voit que tout ceci est rapidement assez scabreux. Cela explique sans
doute l'usage relativement peu répandu des imports relatifs.

De manière générale, une bonne pratique consiste à~:

\begin{itemize}
\tightlist
\item
  considérer votre ou vos points d'entrée comme des accessoires ; un
  point d'entrée typiquement se contente d'importer une classe d'un
  module, de créer une instance et de lui envoyer une méthode ;
\item
  toujours placer ces points d'entrée dans un répertoire séparé ;
\item
  notamment si vous utilisez \texttt{setuptools} pour distribuer votre
  application via \texttt{pypi.org}, vous verrez que ces points d'entrée
  sont complètement pris en charge par les outils d'installation.
\end{itemize}

S'agissant des tests:

\begin{itemize}
\tightlist
\item
  la technique qu'on a vue rapidement - de tester si
  \texttt{\_\_name\_\_} vaut \texttt{"\_\_main\_\_"} - est extrêmement
  basique et limitée. Le mieux est de ne pas l'utiliser en fait, en
  dehors de micro-maquettes.
\item
  en pratique on écrit les tests dans un répertoire séparé - souvent
  appelé \texttt{tests} - et en tirant profit de la librairie
  \texttt{unittest}.
\item
  du coup les tests sont toujours exécutés avec une phrase comme
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[frame=lines,framerule=0.6mm,rulecolor=\color{asisframecolor}]
\ExtensionTok{python3}\NormalTok{ -m unittest tests.jeu_de_tests}
\end{Highlighting}
\end{Shaded}

et dans ce contexte-là, il est possible par exemple pour les tests de
recourir à l'import relatif.

    \hypertarget{pour-en-savoir-plus}{%
\subsubsection{Pour en savoir plus}\label{pour-en-savoir-plus}}

    Vous pourrez consulter~:

\begin{itemize}
\tightlist
\item
  \url{https://www.python.org/dev/peps/pep-0328/} qui date du passage de
  2.4 à 2.5, dans lequel on décide que tous les imports sans \texttt{.}
  sont absolus - ce n'était pas le cas au préalable.
\item
  \url{https://www.python.org/dev/peps/pep-0366/} qui introduit la
  possibilité de définir \texttt{\_\_package\_\_} pour contourner les
  problèmes liés aux imports relatifs dans un script.
\item
  \url{http://sametmax.com/un-gros-guide-bien-gras-sur-les-tests-unitaires-en-python-partie-1/}
  qui parle des tests unitaires qui est un tout autre et vaste sujet.
\end{itemize}


    % Add a bibliography block to the postdoc
    
    
    
