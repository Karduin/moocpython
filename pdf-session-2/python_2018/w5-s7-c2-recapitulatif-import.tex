    
    
    
    

    

    \hypertarget{ruxe9capitulatif-sur-import}{%
\section{\texorpdfstring{Récapitulatif sur
\texttt{import}}{Récapitulatif sur import}}\label{ruxe9capitulatif-sur-import}}

    \hypertarget{compluxe9ment---niveau-basique}{%
\subsection{Complément - niveau
basique}\label{compluxe9ment---niveau-basique}}

    Nous allons récapituler les différentes formes d'importation, et
introduire la clause \texttt{import\ *} - et voir pourquoi il est
déconseillé de l'utiliser.

    \hypertarget{importer-tout-un-module}{%
\subsubsection{Importer tout un module}\label{importer-tout-un-module}}

    L'\texttt{import} le plus simple consiste donc à uniquement mentionner
le nom du module

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}1}]:} \PY{k+kn}{import} \PY{n+nn}{un\PYZus{}deux}
\end{Verbatim}


    Ce module se contente de définir deux fonctions de noms \texttt{un} et
\texttt{deux}. Une fois l'import réalisé de cette façon, on peut accéder
au contenu du module en utilisant un nom de variable complet~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}2}]:} \PY{c+c1}{\PYZsh{} la fonction elle\PYZhy{}même}
        \PY{n+nb}{print}\PY{p}{(}\PY{n}{un\PYZus{}deux}\PY{o}{.}\PY{n}{un}\PY{p}{)}
        
        \PY{n}{un\PYZus{}deux}\PY{o}{.}\PY{n}{un}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
<function un at 0x10c868f28>
la fonction un dans le module un\_deux
\end{Verbatim}

    Mais bien sûr on n'a pas de cette façon défini de nouvelle variable
\texttt{un}~; la seule nouvelle variable dans la portée courante est
donc \texttt{un\_deux}~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}3}]:} \PY{c+c1}{\PYZsh{} dans l\PYZsq{}espace de nommage courant on peut accéder au module lui\PYZhy{}même}
        \PY{n+nb}{print}\PY{p}{(}\PY{n}{un\PYZus{}deux}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
<module 'un\_deux' from '/Users/tparment/git/flotpython/modules/un\_deux.py'>
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}4}]:} \PY{c+c1}{\PYZsh{} mais pas à la variable `un`}
        \PY{k}{try}\PY{p}{:}
            \PY{n+nb}{print}\PY{p}{(}\PY{n}{un}\PY{p}{)}
        \PY{k}{except} \PY{n+ne}{NameError}\PY{p}{:} 
            \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{La variable }\PY{l+s+s2}{\PYZsq{}}\PY{l+s+s2}{un}\PY{l+s+s2}{\PYZsq{}}\PY{l+s+s2}{ n}\PY{l+s+s2}{\PYZsq{}}\PY{l+s+s2}{est pas définie}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
La variable 'un' n'est pas définie
\end{Verbatim}

    \hypertarget{importer-une-variable-spuxe9cifique-dun-module}{%
\subsubsection{Importer une variable spécifique d'un
module}\label{importer-une-variable-spuxe9cifique-dun-module}}

    On peut également importer un ou plusieurs symboles spécifiques d'un
module en faisant maintenant (avec un nouveau module du même tonneau)~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}5}]:} \PY{k+kn}{from} \PY{n+nn}{un\PYZus{}deux\PYZus{}trois} \PY{k}{import} \PY{n}{un}\PY{p}{,} \PY{n}{deux}
\end{Verbatim}


    À présent nous avons deux nouvelles variables dans la portée locale~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}6}]:} \PY{n}{un}\PY{p}{(}\PY{p}{)}
        \PY{n}{deux}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
la fonction un dans le module un\_deux\_trois
la fonction deux dans le module un\_deux\_trois
\end{Verbatim}

    Et cette fois, c'est le module lui-même qui n'est pas accessible~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}7}]:} \PY{k}{try}\PY{p}{:}
            \PY{n+nb}{print}\PY{p}{(}\PY{n}{un\PYZus{}deux\PYZus{}trois}\PY{p}{)}
        \PY{k}{except} \PY{n+ne}{NameError}\PY{p}{:}
            \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{La variable }\PY{l+s+s2}{\PYZsq{}}\PY{l+s+s2}{un\PYZus{}deux\PYZus{}trois}\PY{l+s+s2}{\PYZsq{}}\PY{l+s+s2}{ n}\PY{l+s+s2}{\PYZsq{}}\PY{l+s+s2}{est pas définie}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
La variable 'un\_deux\_trois' n'est pas définie
\end{Verbatim}

    Il est important de voir que la variable locale ainsi créée, un peu
comme dans le cas d'un appel de fonction, est une \textbf{nouvelle
variable} qui est initialisée avec l'objet du module. Ainsi si on
importe le module \textbf{et} une variable du module comme ceci~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}8}]:} \PY{k+kn}{import} \PY{n+nn}{un\PYZus{}deux\PYZus{}trois}
\end{Verbatim}


    alors nous avons maintenant \textbf{deux variables différentes} qui
désignent la fonction \texttt{un} dans le module~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}9}]:} \PY{n+nb}{print}\PY{p}{(}\PY{n}{un\PYZus{}deux\PYZus{}trois}\PY{o}{.}\PY{n}{un}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{n}{un}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ce sont deux façons d}\PY{l+s+s2}{\PYZsq{}}\PY{l+s+s2}{accéder au même objet}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{un} \PY{o+ow}{is} \PY{n}{un\PYZus{}deux\PYZus{}trois}\PY{o}{.}\PY{n}{un}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
<function un at 0x10c88a268>
<function un at 0x10c88a268>
ce sont deux façons d'accéder au même objet True
\end{Verbatim}

    En on peut modifier l'une \textbf{sans affecter} l'autre~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}10}]:} \PY{c+c1}{\PYZsh{} les deux variables sont différentes}
         \PY{c+c1}{\PYZsh{} un n\PYZsq{}est pas un \PYZsq{}alias\PYZsq{} vers un\PYZus{}deux\PYZus{}trois.un}
         \PY{n}{un} \PY{o}{=} \PY{l+m+mi}{1}
         \PY{n+nb}{print}\PY{p}{(}\PY{n}{un\PYZus{}deux\PYZus{}trois}\PY{o}{.}\PY{n}{un}\PY{p}{)}
         \PY{n+nb}{print}\PY{p}{(}\PY{n}{un}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
<function un at 0x10c88a268>
1
\end{Verbatim}

    \hypertarget{compluxe9ment---niveau-intermuxe9diaire}{%
\subsection{Complément - niveau
intermédiaire}\label{compluxe9ment---niveau-intermuxe9diaire}}

    \hypertarget{import-..-as}{%
\subsubsection{\texorpdfstring{\texttt{import} ..
\texttt{as}}{import .. as}}\label{import-..-as}}

    Que l'on importe avec la forme \texttt{import\ unmodule} ou avec la
forme \texttt{from\ unmodule\ import\ unevariable}, on peut toujours
ajouter une clause \texttt{as\ nouveaunom}, qui change le nom de la
variable qui est ajoutée dans l'environnement courant.

    Ainsi~:

\begin{itemize}
\tightlist
\item
  \texttt{import\ foo} définit une variable \texttt{foo} qui désigne un
  module~;
\item
  \texttt{import\ foo\ as\ bar} a le même effet, sauf que le module est
  accessible par la variable \texttt{bar}~;
\end{itemize}

    Et~:

\begin{itemize}
\tightlist
\item
  \texttt{from\ foo\ import\ var} définit une variable \texttt{var} qui
  désigne un attribut du module~;
\item
  \texttt{from\ foo\ import\ var\ as\ newvar} définit une variable
  \texttt{newvar} qui désigne ce même attribut.
\end{itemize}

    Ces deux formes sont pratiques pour éviter les conflits de nom.

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}11}]:} \PY{c+c1}{\PYZsh{} par exemple}
         \PY{k+kn}{import} \PY{n+nn}{un\PYZus{}deux} \PY{k}{as} \PY{n+nn}{mod12}
         \PY{n}{mod12}\PY{o}{.}\PY{n}{un}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
la fonction un dans le module un\_deux
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}12}]:} \PY{k+kn}{from} \PY{n+nn}{un\PYZus{}deux} \PY{k}{import} \PY{n}{deux} \PY{k}{as} \PY{n}{m12deux}
         \PY{n}{m12deux}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
la fonction deux dans le module un\_deux
\end{Verbatim}

    \hypertarget{import}{%
\subsubsection{\texorpdfstring{\texttt{import\ *}}{import *}}\label{import}}

    La dernière forme d'\texttt{import} consiste à importer toutes les
variables d'un module comme ceci~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}13}]:} \PY{k+kn}{from} \PY{n+nn}{un\PYZus{}deux\PYZus{}trois\PYZus{}quatre} \PY{k}{import} \PY{o}{*}
\end{Verbatim}


    Cette forme, pratique en apparence, va donc créer dans l'espace de
nommage courant les variables

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}14}]:} \PY{n}{un}\PY{p}{(}\PY{p}{)}
         \PY{n}{deux}\PY{p}{(}\PY{p}{)}
         \PY{n}{trois}\PY{p}{(}\PY{p}{)}
         \PY{n}{quatre}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
la fonction un dans le module un\_deux\_trois\_quatre
la fonction deux dans le module un\_deux\_trois\_quatre
la fonction trois dans le module un\_deux\_trois\_quatre
la fonction quatre dans le module un\_deux\_trois\_quatre
\end{Verbatim}

    \hypertarget{quand-utiliser-telle-ou-telle-forme}{%
\subsubsection{Quand utiliser telle ou telle
forme}\label{quand-utiliser-telle-ou-telle-forme}}

    Les deux premières formes - import d'un module ou de variables
spécifiques - peuvent être utilisées indifféremment~; souvent lorsqu'une
variable est utilisée très souvent dans le code on pourra préférer la
deuxième forme pour raccourcir le code.

    À cet égard, citons des variantes de ces deux formes qui permettent
d'utiliser des noms plus courts. Vous trouverez par exemple très souvent

\begin{Shaded}
\begin{Highlighting}[frame=lines,framerule=0.6mm,rulecolor=\color{asisframecolor}]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\end{Highlighting}
\end{Shaded}

qui permet d'importer le module numpy mais de l'utiliser sous un nom
plus court - car avec \texttt{numpy} on ne cesse d'utiliser des symboles
dans le module.

    \textbf{Avertissement~:} nous vous recommandons de \textbf{ne pas
utiliser la dernière forme \texttt{import\ *}} - sauf dans
l'interpréteur interactif - car cela peut gravement nuire à la
lisibilité de votre code.

    python est un langage à liaison statique~; cela signifie que lorsque
vous concentrez votre attention sur un (votre) module, et que vous voyez
une référence en lecture à une variable \texttt{spam} disons à la ligne
201, vous devez forcément trouver dans les deux cents premières lignes
quelque chose comme une déclaration de \texttt{spam}, qui vous indique
en gros d'où elle vient.

\texttt{import\ *} est une construction qui casse cette bonne propriété
(pour être tout à fait exhaustif, cette bonne propriété n'est pas non
plus remplie avec les fonctions \emph{built-in} comme \texttt{len}, mais
il faut vivre avec\ldots{})

Mais le point important est ceci~: imaginez que dans un module vous
faites plusieurs \texttt{import\ *} comme par exemple

\begin{Shaded}
\begin{Highlighting}[frame=lines,framerule=0.6mm,rulecolor=\color{asisframecolor}]
\ImportTok{from}\NormalTok{ django.db }\ImportTok{import} \OperatorTok{*}
\ImportTok{from}\NormalTok{ django.conf.urls }\ImportTok{import} \OperatorTok{*}
\end{Highlighting}
\end{Shaded}

Peu importe le contenu exact de ces deux modules, il nous suffit de
savoir qu'un des deux modules expose la variable \texttt{patterns}.

Dans ce cas de figure vécu, le module utilise cette variable
\texttt{patterns} sans avoir besoin de la déclarer explicitement, si
bien qu'à la lecture on voit une utilisation de la variable
\texttt{patterns}, mais on n'a plus aucune idée de quel module elle
provient, sauf à aller lire le code correspondant\ldots{}

    \hypertarget{compluxe9ment---niveau-avancuxe9}{%
\subsection{Complément - niveau
avancé}\label{compluxe9ment---niveau-avancuxe9}}

    \hypertarget{import-de-maniuxe8re-programmative}{%
\subsubsection{\texorpdfstring{\texttt{import} de manière
``programmative''}{import de manière ``programmative''}}\label{import-de-maniuxe8re-programmative}}

    Étant donné la façon dont est conçue l'instruction \texttt{import}, on
rencontre une limitation lorsqu'on veut, par exemple, \textbf{calculer
le nom d'un module} avant de l'importer.

Si vous êtes dans ce genre de situation, reportez-vous au module
\href{https://docs.python.org/3/library/importlib.html}{\texttt{importlib}}
et notamment sa fonction \texttt{import\_module} qui, cette fois,
accepte en argument une chaîne.

    Voici une illustration dans un cas simple. Nous allons importer le
module \texttt{modtools} (qui fait partie de ce MOOC) de deux façons
différentes et montrer que le résultat est le même~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}15}]:} \PY{c+c1}{\PYZsh{} on importe la fonction \PYZsq{}import\PYZus{}module\PYZsq{} du module \PYZsq{}importlib\PYZsq{}}
         \PY{k+kn}{from} \PY{n+nn}{importlib} \PY{k}{import} \PY{n}{import\PYZus{}module}
         
         \PY{c+c1}{\PYZsh{} grâce à laquelle on peut importer à partir d\PYZsq{}un string }
         \PY{n}{imported\PYZus{}modtools} \PY{o}{=} \PY{n}{import\PYZus{}module}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{mod}\PY{l+s+s1}{\PYZsq{}} \PY{o}{+} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{tools}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} on peut aussi importer modtools \PYZdq{}normalement\PYZdq{}}
         \PY{k+kn}{import} \PY{n+nn}{modtools}
         
         \PY{c+c1}{\PYZsh{} les deux objets sont identiques}
         \PY{n}{imported\PYZus{}modtools} \PY{o+ow}{is} \PY{n}{modtools}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}15}]:} True
\end{Verbatim}
            
    \hypertarget{imports-relatifs}{%
\subsubsection{Imports relatifs}\label{imports-relatifs}}

    Il existe aussi en python une façon d'importer des modules, non pas
directement en cherchant depuis \texttt{sys.path}, mais en cherchant à
partir du module où se trouve la clause \texttt{import}. Nous détaillons
ce trait dans un complément ultérieur.


    % Add a bibliography block to the postdoc
    
    
    
