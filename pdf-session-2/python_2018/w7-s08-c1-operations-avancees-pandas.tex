    
    
    
    

    

    \hypertarget{opuxe9ration-avancuxe9es-en-pandas}{%
\section{\texorpdfstring{Opération avancées en
\texttt{pandas}}{Opération avancées en pandas}}\label{opuxe9ration-avancuxe9es-en-pandas}}

    \hypertarget{compluxe9ment---niveau-intermuxe9diaire}{%
\subsection{Complément - niveau
intermédiaire}\label{compluxe9ment---niveau-intermuxe9diaire}}

    \hypertarget{introduction}{%
\subsubsection{Introduction}\label{introduction}}

    \texttt{pandas} supporte des opérations de manipulation des
\texttt{Series} et \texttt{DataFrame} qui sont similaires dans l'esprit
à ce que l'on peut faire avec une base de données et le langage SQL,
mais de manière plus intuitive et expressive et beaucoup plus
efficacement puisque les opérations se déroulent toutes en mémoire.

Vous pouvez concaténer (\texttt{concat}) des \texttt{DataFrame}, faire
des jointures (\texttt{merge}), faire des regroupements
(\texttt{groupby}) ou réorganiser les index (\texttt{pivot}).

Nous allons dans la suite développer ces différentes techniques.

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}1}]:} \PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}
        \PY{k+kn}{import} \PY{n+nn}{pandas} \PY{k}{as} \PY{n+nn}{pd}
\end{Verbatim}


    \hypertarget{concatuxe9nations-avec-concat}{%
\subsubsection{\texorpdfstring{Concaténations avec
\texttt{concat}}{Concaténations avec concat}}\label{concatuxe9nations-avec-concat}}

    \texttt{concat} est utilisé pour concaténer des \texttt{Series} ou des
\texttt{DataFrame}. Regardons un exemple.

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}2}]:} \PY{n}{s1} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{Series}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{30}\PY{p}{,} \PY{l+m+mi}{35}\PY{p}{]}\PY{p}{,} \PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{alice}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{bob}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
        \PY{n}{s2} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{Series}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{32}\PY{p}{,} \PY{l+m+mi}{22}\PY{p}{,} \PY{l+m+mi}{29}\PY{p}{]}\PY{p}{,} \PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{bill}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{alice}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{jo}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}3}]:} \PY{n}{s1}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}3}]:} alice    30
        bob      35
        dtype: int64
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}4}]:} \PY{n}{s2}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}4}]:} bill     32
        alice    22
        jo       29
        dtype: int64
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}5}]:} \PY{n}{pd}\PY{o}{.}\PY{n}{concat}\PY{p}{(}\PY{p}{[}\PY{n}{s1}\PY{p}{,} \PY{n}{s2}\PY{p}{]}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}5}]:} alice    30
        bob      35
        bill     32
        alice    22
        jo       29
        dtype: int64
\end{Verbatim}
            
    On remarque, cependant, que par défaut il n'y a pas de contrôle sur les
labels d'index dupliqués. On peut corriger cela avec l'argument
\texttt{verify\_integrity}, qui va produire une exception s'il y a des
labels d'index communs. Évidemment, cela a un coût de calcul
supplémentaire, ça n'est donc à utiliser que si c'est nécessaire.

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}6}]:} \PY{k}{try}\PY{p}{:}
            \PY{n}{pd}\PY{o}{.}\PY{n}{concat}\PY{p}{(}\PY{p}{[}\PY{n}{s1}\PY{p}{,} \PY{n}{s2}\PY{p}{]}\PY{p}{,} \PY{n}{verify\PYZus{}integrity}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}
        \PY{k}{except} \PY{n+ne}{ValueError} \PY{k}{as} \PY{n}{e}\PY{p}{:}
            \PY{n+nb}{print}\PY{p}{(}\PY{n}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{erreur de concaténation:}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+si}{\PYZob{}e\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
erreur de concaténation:
Indexes have overlapping values: Index(['alice'], dtype='object')
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}7}]:} \PY{c+c1}{\PYZsh{} créons deux Series avec les index sans recouvrement}
        \PY{n}{s1} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{Series}\PY{p}{(}\PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{1000}\PY{p}{)}\PY{p}{,} \PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{n+nb}{chr}\PY{p}{(}\PY{n}{x}\PY{p}{)} \PY{k}{for} \PY{n}{x} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{1000}\PY{p}{)}\PY{p}{]}\PY{p}{)}
        \PY{n}{s2} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{Series}\PY{p}{(}\PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{1000}\PY{p}{)}\PY{p}{,} \PY{n}{index}\PY{o}{=}\PY{p}{[}\PY{n+nb}{chr}\PY{p}{(}\PY{n}{x}\PY{o}{+}\PY{l+m+mi}{2000}\PY{p}{)} \PY{k}{for} \PY{n}{x} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{1000}\PY{p}{)}\PY{p}{]}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}8}]:} \PY{c+c1}{\PYZsh{} temps de concaténation avec vérification des recouvrements}
        \PY{o}{\PYZpc{}}\PY{k}{timeit} pd.concat([s1, s2], verify\PYZus{}integrity=True)
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
504 µs ± 14.6 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}9}]:} \PY{c+c1}{\PYZsh{} temps de concaténation sans vérification des recouvrements}
        \PY{o}{\PYZpc{}}\PY{k}{timeit} pd.concat([s1, s2])
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
331 µs ± 13.3 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
\end{Verbatim}

    Par défaut, \texttt{concat} concatène les lignes, c'est-à-dire que
\texttt{s2} sera sous \texttt{s1}, mais on peut changer ce comportement
en utilisant l'argument \texttt{axis}~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}10}]:} \PY{n}{p1} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{DataFrame}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{random}\PY{o}{.}\PY{n}{randint}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{10}\PY{p}{,} \PY{n}{size}\PY{o}{=}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)}\PY{p}{,}
                           \PY{n}{columns}\PY{o}{=}\PY{n+nb}{list}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ab}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{,} \PY{n}{index}\PY{o}{=}\PY{n+nb}{list}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{xy}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}
         \PY{n}{p2} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{DataFrame}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{random}\PY{o}{.}\PY{n}{randint}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{10}\PY{p}{,} \PY{n}{size}\PY{o}{=}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)}\PY{p}{,}
                           \PY{n}{columns}\PY{o}{=}\PY{n+nb}{list}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ab}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{,} \PY{n}{index}\PY{o}{=}\PY{n+nb}{list}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{zt}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}11}]:} \PY{n}{p1}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}11}]:}    a  b
         x  1  3
         y  2  3
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}12}]:} \PY{n}{p2}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}12}]:}    a  b
         z  8  9
         t  1  3
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}13}]:} \PY{c+c1}{\PYZsh{} équivalent à pd.concat([p1, p2], axis=0)}
         \PY{c+c1}{\PYZsh{} concaténation des lignes}
         \PY{n}{pd}\PY{o}{.}\PY{n}{concat}\PY{p}{(}\PY{p}{[}\PY{n}{p1}\PY{p}{,} \PY{n}{p2}\PY{p}{]}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}13}]:}    a  b
         x  1  3
         y  2  3
         z  8  9
         t  1  3
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}14}]:} \PY{n}{p1} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{DataFrame}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{random}\PY{o}{.}\PY{n}{randint}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{10}\PY{p}{,} \PY{n}{size}\PY{o}{=}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)}\PY{p}{,}
                           \PY{n}{columns}\PY{o}{=}\PY{n+nb}{list}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ab}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{,} \PY{n}{index}\PY{o}{=}\PY{n+nb}{list}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{xy}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}
         \PY{n}{p2} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{DataFrame}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{random}\PY{o}{.}\PY{n}{randint}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{10}\PY{p}{,} \PY{n}{size}\PY{o}{=}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)}\PY{p}{,}
                           \PY{n}{columns}\PY{o}{=}\PY{n+nb}{list}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{cd}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{,} \PY{n}{index}\PY{o}{=}\PY{n+nb}{list}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{xy}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}15}]:} \PY{n}{p1}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}15}]:}    a  b
         x  8  3
         y  6  2
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}16}]:} \PY{n}{p2}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}16}]:}    c  d
         x  8  6
         y  6  4
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}17}]:} \PY{c+c1}{\PYZsh{} concaténation des colonnes}
         \PY{n}{pd}\PY{o}{.}\PY{n}{concat}\PY{p}{(}\PY{p}{[}\PY{n}{p1}\PY{p}{,} \PY{n}{p2}\PY{p}{]}\PY{p}{,} \PY{n}{axis}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}17}]:}    a  b  c  d
         x  8  3  8  6
         y  6  2  6  4
\end{Verbatim}
            
    Regardons maintenant ce cas~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}18}]:} \PY{n}{pd}\PY{o}{.}\PY{n}{concat}\PY{p}{(}\PY{p}{[}\PY{n}{p1}\PY{p}{,} \PY{n}{p2}\PY{p}{]}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
/usr/local/lib/python3.7/site-packages/ipykernel\_launcher.py:1: FutureWarning: Sorting because non-concatenation axis is not aligned. A future version
of pandas will change to not sort by default.

To accept the future behavior, pass 'sort=False'.

To retain the current behavior and silence the warning, pass 'sort=True'.

  """Entry point for launching an IPython kernel.
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}18}]:}      a    b    c    d
         x  8.0  3.0  NaN  NaN
         y  6.0  2.0  NaN  NaN
         x  NaN  NaN  8.0  6.0
         y  NaN  NaN  6.0  4.0
\end{Verbatim}
            
    Vous remarquez que lors de la concaténation, on prend l'union des tous
les labels des index de \texttt{p1} et \texttt{p2}, il y a donc des
valeurs absentes qui sont mises à \texttt{NaN}. On peut contrôler ce
comportement de plusieurs manières comme nous allons le voir ci-dessous.

    Par défaut (ce que l'on a fait ci-dessus), join utilise la stratégie
dite \texttt{outer}, c'est-à-dire qu'on prend l'union des labels.

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}19}]:} \PY{c+c1}{\PYZsh{} on concatène les lignes, l\PYZsq{}argument join décide quels labels on garde}
         \PY{c+c1}{\PYZsh{} sur l\PYZsq{}autre axe  (ici sur les colonnes).}
         
         \PY{c+c1}{\PYZsh{} si on spécifie \PYZsq{}inner\PYZsq{} on prend l\PYZsq{}intersection des labels}
         \PY{c+c1}{\PYZsh{} du coup il ne reste rien ..}
         \PY{n}{pd}\PY{o}{.}\PY{n}{concat}\PY{p}{(}\PY{p}{[}\PY{n}{p1}\PY{p}{,} \PY{n}{p2}\PY{p}{]}\PY{p}{,} \PY{n}{join}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{inner}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}19}]:} Empty DataFrame
         Columns: []
         Index: [x, y, x, y]
\end{Verbatim}
            
    Avec \texttt{join\_axes}, on peut spécifier les labels qu'on veut
garder, sous la forme d'un objet \texttt{Index}~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}20}]:} \PY{n}{pd}\PY{o}{.}\PY{n}{concat}\PY{p}{(}\PY{p}{[}\PY{n}{p1}\PY{p}{,} \PY{n}{p2}\PY{p}{]}\PY{p}{,} \PY{n}{join\PYZus{}axes}\PY{o}{=}\PY{p}{[}\PY{n}{p1}\PY{o}{.}\PY{n}{columns}\PY{p}{]}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}20}]:}      a    b
         x  8.0  3.0
         y  6.0  2.0
         x  NaN  NaN
         y  NaN  NaN
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}21}]:} \PY{c+c1}{\PYZsh{} du coup je peux choisir très finement}
         \PY{n}{pd}\PY{o}{.}\PY{n}{concat}\PY{p}{(}\PY{p}{[}\PY{n}{p1}\PY{p}{,} \PY{n}{p2}\PY{p}{]}\PY{p}{,} \PY{n}{join\PYZus{}axes}\PY{o}{=}\PY{p}{[}\PY{n}{pd}\PY{o}{.}\PY{n}{Index}\PY{p}{(}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{a}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{c}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{)}\PY{p}{]}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}21}]:}      a    c
         x  8.0  NaN
         y  6.0  NaN
         x  NaN  8.0
         y  NaN  6.0
\end{Verbatim}
            
    Notons que les \texttt{Series} et \texttt{DataFrame} ont une méthode
\texttt{append} qui est un raccourci vers \texttt{concat}, mais avec
moins d'options.

Pour aller plus loin, voici la documentation officielle~:

http://pandas.pydata.org/pandas-docs/stable/merging.html\#concatenating-objects

    \hypertarget{jointures-avec-merge}{%
\subsubsection{\texorpdfstring{Jointures avec
\texttt{merge}}{Jointures avec merge}}\label{jointures-avec-merge}}

    \texttt{merge} est dans l'esprit similaire au \texttt{JOIN} en SQL.
L'idée est de combiner deux \texttt{DataFrame} en fonction d'un critère
d'égalité sur des colonnes. Regardons un exemple~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}22}]:} \PY{n}{df1} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{DataFrame}\PY{p}{(}\PY{p}{\PYZob{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{employee}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Bob}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Lisa}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Sue}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,}
                             \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{group}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Accounting}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Engineering}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{HR}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{\PYZcb{}}\PY{p}{)}
         \PY{n}{df2} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{DataFrame}\PY{p}{(}\PY{p}{\PYZob{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{employee}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Lisa}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Bob}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Sue}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,}
                             \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{hire\PYZus{}date}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{p}{[}\PY{l+m+mi}{2004}\PY{p}{,} \PY{l+m+mi}{2008}\PY{p}{,} \PY{l+m+mi}{2014}\PY{p}{]}\PY{p}{\PYZcb{}}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}23}]:} \PY{n}{df1}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}23}]:}   employee        group
         0      Bob   Accounting
         1     Lisa  Engineering
         2      Sue           HR
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}24}]:} \PY{n}{df2}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}24}]:}   employee  hire\_date
         0     Lisa       2004
         1      Bob       2008
         2      Sue       2014
\end{Verbatim}
            
    On souhaite ici combiner \texttt{df1} et \texttt{df2} de manière à ce
que les lignes contenant le même \emph{employee} soient alignées. Notre
critère de merge est donc l'égalité des labels sur la colonne
\emph{employee}.

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}25}]:} \PY{n}{pd}\PY{o}{.}\PY{n}{merge}\PY{p}{(}\PY{n}{df1}\PY{p}{,} \PY{n}{df2}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}25}]:}   employee        group  hire\_date
         0      Bob   Accounting       2008
         1     Lisa  Engineering       2004
         2      Sue           HR       2014
\end{Verbatim}
            
    Par défaut, \texttt{merge} fait un \emph{inner join} (ou jointure
interne) en utilisant comme critère de jointure les colonnes de même nom
(ici \texttt{employee}). \emph{inner join} veut dire que pour joindre
deux lignes il faut que le même \texttt{employee} apparaisse dans les
deux \texttt{DataFrame}.

    Il existe trois type de merges~:

\begin{itemize}
\item
  one-to-one, c'est celui que l'on vient de voir. C'est le merge
  lorqu'il n'y a pas de labels dupliqués dans les colonnes utilisées
  comme critère de merge~;
\item
  many-to-one, c'est le merge lorsque l'une des deux colonnes contient
  des labels dupliqués, dans ce cas, on applique la stratégie one-to-one
  pour chaque label dupliqué, donc les entrées dupliquées sont
  préservées~;
\item
  many-to-many, c'est la stratégie lorsqu'il y a des entrées dupliquées
  dans les deux colonnes. Dans ce cas, on fait un produit cartésien des
  lignes.
\end{itemize}

D'une manière générale, gardez en tête que \texttt{pandas} fait
essentiellement ce à quoi on s'attend. Regardons cela sur des exemples~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}26}]:} \PY{n}{df1} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{DataFrame}\PY{p}{(}\PY{p}{\PYZob{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{patient}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Bob}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Lisa}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Sue}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,}
                             \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{repas}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{SS}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{SS}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{SSR}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{\PYZcb{}}\PY{p}{)}
         \PY{n}{df2} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{DataFrame}\PY{p}{(}\PY{p}{\PYZob{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{repas}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{SS}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{SSR}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,}
                             \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{explication}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{sans sel}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{sans sucre}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{\PYZcb{}}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}27}]:} \PY{n}{df1}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}27}]:}   patient repas
         0     Bob    SS
         1    Lisa    SS
         2     Sue   SSR
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}28}]:} \PY{n}{df2}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}28}]:}   repas explication
         0    SS    sans sel
         1   SSR  sans sucre
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}29}]:} \PY{c+c1}{\PYZsh{} la colonne commune pour le merge est \PYZsq{}repas\PYZsq{} et dans une des colonnes}
         \PY{c+c1}{\PYZsh{} (sur df1), il y a des labels dupliqués, on applique la stratégie many\PYZhy{}to\PYZhy{}one}
         \PY{n}{pd}\PY{o}{.}\PY{n}{merge}\PY{p}{(}\PY{n}{df1}\PY{p}{,} \PY{n}{df2}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}29}]:}   patient repas explication
         0     Bob    SS    sans sel
         1    Lisa    SS    sans sel
         2     Sue   SSR  sans sucre
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}30}]:} \PY{n}{df1} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{DataFrame}\PY{p}{(}\PY{p}{\PYZob{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{patient}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Bob}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Lisa}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Sue}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,}
                             \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{repas}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{SS}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{SS}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{SSR}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{\PYZcb{}}\PY{p}{)}
         \PY{n}{df2} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{DataFrame}\PY{p}{(}\PY{p}{\PYZob{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{repas}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{SS}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{SS}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{SSR}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,}
                             \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{explication}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{sans sel}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{légumes}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{sans sucre}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{\PYZcb{}}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}31}]:} \PY{n}{df1}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}31}]:}   patient repas
         0     Bob    SS
         1    Lisa    SS
         2     Sue   SSR
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}32}]:} \PY{n}{df2}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}32}]:}   repas explication
         0    SS    sans sel
         1    SS     légumes
         2   SSR  sans sucre
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}33}]:} \PY{c+c1}{\PYZsh{} la colonne commune pour le merge est \PYZsq{}repas\PYZsq{} et dans les deux colonnes}
         \PY{c+c1}{\PYZsh{} il y a des labels dupliqués, on applique la stratégie many\PYZhy{}to\PYZhy{}many}
         \PY{n}{pd}\PY{o}{.}\PY{n}{merge}\PY{p}{(}\PY{n}{df1}\PY{p}{,}\PY{n}{df2}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}33}]:}   patient repas explication
         0     Bob    SS    sans sel
         1     Bob    SS     légumes
         2    Lisa    SS    sans sel
         3    Lisa    SS     légumes
         4     Sue   SSR  sans sucre
\end{Verbatim}
            
    Dans un merge, on peut contrôler les colonnes à utiliser comme critère
de merge. Regardons ces différents cas sur des exemples~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}34}]:} \PY{n}{df1} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{DataFrame}\PY{p}{(}\PY{p}{\PYZob{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{employee}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Bob}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Lisa}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Sue}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,}
                             \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{group}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Accounting}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Engineering}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{HR}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{\PYZcb{}}\PY{p}{)}
         \PY{n}{df2} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{DataFrame}\PY{p}{(}\PY{p}{\PYZob{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{employee}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Lisa}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Bob}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Sue}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,}
                             \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{hire\PYZus{}date}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{p}{[}\PY{l+m+mi}{2004}\PY{p}{,} \PY{l+m+mi}{2008}\PY{p}{,} \PY{l+m+mi}{2014}\PY{p}{]}\PY{p}{\PYZcb{}}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}35}]:} \PY{n}{df1}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}35}]:}   employee        group
         0      Bob   Accounting
         1     Lisa  Engineering
         2      Sue           HR
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}36}]:} \PY{n}{df2}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}36}]:}   employee  hire\_date
         0     Lisa       2004
         1      Bob       2008
         2      Sue       2014
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}37}]:} \PY{c+c1}{\PYZsh{} on décide d\PYZsq{}utiliser la colonne \PYZsq{}employee\PYZsq{} comme critère de merge}
         \PY{n}{pd}\PY{o}{.}\PY{n}{merge}\PY{p}{(}\PY{n}{df1}\PY{p}{,} \PY{n}{df2}\PY{p}{,} \PY{n}{on}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{employee}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}37}]:}   employee        group  hire\_date
         0      Bob   Accounting       2008
         1     Lisa  Engineering       2004
         2      Sue           HR       2014
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}38}]:} \PY{n}{df1} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{DataFrame}\PY{p}{(}\PY{p}{\PYZob{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{employee}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Bob}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Lisa}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Sue}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,}
                             \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{group}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Accounting}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Engineering}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{HR}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{\PYZcb{}}\PY{p}{)}
         \PY{n}{df2} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{DataFrame}\PY{p}{(}\PY{p}{\PYZob{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{name}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Lisa}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Bob}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Sue}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,}
                             \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{hire\PYZus{}date}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{p}{[}\PY{l+m+mi}{2004}\PY{p}{,} \PY{l+m+mi}{2008}\PY{p}{,} \PY{l+m+mi}{2014}\PY{p}{]}\PY{p}{\PYZcb{}}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}39}]:} \PY{n}{df1}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}39}]:}   employee        group
         0      Bob   Accounting
         1     Lisa  Engineering
         2      Sue           HR
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}40}]:} \PY{n}{df2}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}40}]:}    name  hire\_date
         0  Lisa       2004
         1   Bob       2008
         2   Sue       2014
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}41}]:} \PY{c+c1}{\PYZsh{} mais on peut également définir un nom de colonne différent}
         \PY{c+c1}{\PYZsh{} à gauche et à droite}
         \PY{n}{m} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{merge}\PY{p}{(}\PY{n}{df1}\PY{p}{,}\PY{n}{df2}\PY{p}{,} \PY{n}{left\PYZus{}on}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{employee}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{right\PYZus{}on}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{name}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{m}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}41}]:}   employee        group  name  hire\_date
         0      Bob   Accounting   Bob       2008
         1     Lisa  Engineering  Lisa       2004
         2      Sue           HR   Sue       2014
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}42}]:} \PY{c+c1}{\PYZsh{} dans ce cas, comme on garde les colonnes utilisées comme critère dans}
         \PY{c+c1}{\PYZsh{} le résultat du merge, on peut effacer la colonne inutile ainsi}
         \PY{n}{m}\PY{o}{.}\PY{n}{drop}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{name}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{axis}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}42}]:}   employee        group  hire\_date
         0      Bob   Accounting       2008
         1     Lisa  Engineering       2004
         2      Sue           HR       2014
\end{Verbatim}
            
    \texttt{merge} permet également de contrôler la stratégie à appliquer
lorsqu'il y a des valeurs dans une colonne utilisée comme critère de
merge qui sont absentes dans l'autre colonne. C'est ce que l'on appelle
jointure à gauche, jointure à droite, jointure interne (comportement par
défaut) et jointure externe. Pour ceux qui ne sont pas familiers avec
ces notions, regardons des exemples~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}43}]:} \PY{n}{df1} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{DataFrame}\PY{p}{(}\PY{p}{\PYZob{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{name}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Bob}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Lisa}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Sue}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,}
                             \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{pulse}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{p}{[}\PY{l+m+mi}{70}\PY{p}{,} \PY{l+m+mi}{63}\PY{p}{,} \PY{l+m+mi}{81}\PY{p}{]}\PY{p}{\PYZcb{}}\PY{p}{)}
         \PY{n}{df2} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{DataFrame}\PY{p}{(}\PY{p}{\PYZob{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{name}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Eric}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Bob}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Marc}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,}
                             \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{weight}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{p}{[}\PY{l+m+mi}{60}\PY{p}{,} \PY{l+m+mi}{100}\PY{p}{,} \PY{l+m+mi}{70}\PY{p}{]}\PY{p}{\PYZcb{}}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}44}]:} \PY{n}{df1}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}44}]:}    name  pulse
         0   Bob     70
         1  Lisa     63
         2   Sue     81
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}45}]:} \PY{n}{df2}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}45}]:}    name  weight
         0  Eric      60
         1   Bob     100
         2  Marc      70
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}46}]:} \PY{c+c1}{\PYZsh{} la colonne \PYZsq{}name\PYZsq{} est le critère de merge dans les deux DataFrame.}
         \PY{c+c1}{\PYZsh{} Seul Bob existe dans les deux colonnes. Dans un inner join}
         \PY{c+c1}{\PYZsh{} (le cas par défaut) on ne garde que les lignes pour lesquelles il y a une}
         \PY{c+c1}{\PYZsh{} même valeur présente à gauche et à droite}
         \PY{n}{pd}\PY{o}{.}\PY{n}{merge}\PY{p}{(}\PY{n}{df1}\PY{p}{,} \PY{n}{df2}\PY{p}{)} \PY{c+c1}{\PYZsh{} équivalent à pd.merge(df1, df2, how=\PYZsq{}inner\PYZsq{})}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}46}]:}   name  pulse  weight
         0  Bob     70     100
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}47}]:} \PY{c+c1}{\PYZsh{} le outer join va au contraire faire une union des lignes et compléter ce}
         \PY{c+c1}{\PYZsh{} qui manque avec NaN}
         \PY{n}{pd}\PY{o}{.}\PY{n}{merge}\PY{p}{(}\PY{n}{df1}\PY{p}{,} \PY{n}{df2}\PY{p}{,} \PY{n}{how}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{outer}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}47}]:}    name  pulse  weight
         0   Bob   70.0   100.0
         1  Lisa   63.0     NaN
         2   Sue   81.0     NaN
         3  Eric    NaN    60.0
         4  Marc    NaN    70.0
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}48}]:} \PY{c+c1}{\PYZsh{} le left join ne garde que les valeurs de la colonne de gauche}
         \PY{n}{pd}\PY{o}{.}\PY{n}{merge}\PY{p}{(}\PY{n}{df1}\PY{p}{,} \PY{n}{df2}\PY{p}{,} \PY{n}{how}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{left}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}48}]:}    name  pulse  weight
         0   Bob     70   100.0
         1  Lisa     63     NaN
         2   Sue     81     NaN
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}49}]:} \PY{c+c1}{\PYZsh{} et le right join ne garde que les valeurs de la colonne de droite}
         \PY{n}{pd}\PY{o}{.}\PY{n}{merge}\PY{p}{(}\PY{n}{df1}\PY{p}{,} \PY{n}{df2}\PY{p}{,} \PY{n}{how}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{right}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}49}]:}    name  pulse  weight
         0   Bob   70.0     100
         1  Eric    NaN      60
         2  Marc    NaN      70
\end{Verbatim}
            
    Pour aller plus loin, vous pouvez lire la documentation. Vous verrez
notamment que vous pouvez merger sur les index (au lieu des colonnes) ou
le cas où vous avez des colonnes de même nom qui ne font pas partie du
critère de merge~:

http://pandas.pydata.org/pandas-docs/stable/merging.html\#database-style-dataframe-joining-merging

    \hypertarget{regroupement-avec-groupby}{%
\subsubsection{\texorpdfstring{Regroupement avec
\texttt{groupby}}{Regroupement avec groupby}}\label{regroupement-avec-groupby}}

    Regardons maintenant cette notion de groupement. Il s'agit d'une notion
très puissante avec de nombreuses options que nous ne couvrirons que
partiellement. La logique derrière \texttt{groupby} est de créer des
groupes dans une \texttt{DataFrame} en fonction des valeurs d'une (ou
plusieurs) colonne(s), toutes les lignes contenant la même valeur sont
dans le même groupe. On peut ensuite appliquer à chaque groupe des
opérations qui sont~:

\begin{itemize}
\tightlist
\item
  soit des calculs sur chaque groupe~;
\item
  soit un filtre sur chaque groupe qui peut garder ou supprimer un
  groupe~;
\item
  soit une transformation qui va modifier tout le groupe (par exemple,
  pour centrer les valeurs sur la moyenne du groupe).
\end{itemize}

Regardons quelques exemples~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}50}]:} \PY{n}{d} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{DataFrame}\PY{p}{(}\PY{p}{\PYZob{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{key}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{n+nb}{list}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ABCABC}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{val}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{6}\PY{p}{)}\PY{p}{\PYZcb{}}\PY{p}{)}
         \PY{n}{d}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}50}]:}   key  val
         0   A    0
         1   B    1
         2   C    2
         3   A    3
         4   B    4
         5   C    5
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}51}]:} \PY{c+c1}{\PYZsh{} utilisons comme colonne de groupement \PYZsq{}key\PYZsq{}}
         \PY{n}{g} \PY{o}{=} \PY{n}{d}\PY{o}{.}\PY{n}{groupby}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{key}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{g}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}51}]:} <pandas.core.groupby.groupby.DataFrameGroupBy object at 0x110128320>
\end{Verbatim}
            
    \texttt{groupby} produit un nouvel objet, mais ne fait aucun calcul. Les
calculs seront effectués lors de l'appel d'une fonction sur ce nouvel
objet. Par exemple, calculons la somme pour chaque groupe.

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}52}]:} \PY{n}{g}\PY{o}{.}\PY{n}{sum}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}52}]:}      val
         key     
         A      3
         B      5
         C      7
\end{Verbatim}
            
    \texttt{groupby} peut utiliser comme critère de groupement une colonne,
une liste de colonnes, ou un index (c'est notamment utile pour les
\texttt{Series}).

Une particularité de \texttt{groupby} est que le critère de groupement
devient un index dans le nouvel objet généré. L'avantage est que l'on a
maintenant un accès optimisé sur ce critère, mais l'inconvénient est que
sur certaines opérations qui détruisent l'index on peut perdre ce
critère. On peut contrôler ce comportement avec \texttt{as\_index}.

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}53}]:} \PY{n}{g} \PY{o}{=} \PY{n}{d}\PY{o}{.}\PY{n}{groupby}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{key}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{as\PYZus{}index}\PY{o}{=}\PY{k+kc}{False}\PY{p}{)}
         \PY{n}{g}\PY{o}{.}\PY{n}{sum}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}53}]:}   key  val
         0   A    3
         1   B    5
         2   C    7
\end{Verbatim}
            
    L'objet produit par \texttt{groupby} pemet de manipuler les groupes,
regardons cela~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}54}]:} \PY{n}{d} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{DataFrame}\PY{p}{(}\PY{p}{\PYZob{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{key}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{n+nb}{list}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ABCABC}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{,}
                           \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{val1}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{6}\PY{p}{)}\PY{p}{,}
                           \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{val2}\PY{l+s+s1}{\PYZsq{}} \PY{p}{:} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{100}\PY{p}{,} \PY{l+m+mi}{106}\PY{p}{)}\PY{p}{\PYZcb{}}\PY{p}{)}
         \PY{n}{d}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}54}]:}   key  val1  val2
         0   A     0   100
         1   B     1   101
         2   C     2   102
         3   A     3   103
         4   B     4   104
         5   C     5   105
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}55}]:} \PY{n}{g} \PY{o}{=} \PY{n}{d}\PY{o}{.}\PY{n}{groupby}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{key}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} g.groups donne accès au dictionnaire des groupes,}
         \PY{c+c1}{\PYZsh{} les clefs sont le nom du groupe}
         \PY{c+c1}{\PYZsh{} et les valeurs les index des lignes}
         \PY{c+c1}{\PYZsh{} appartenant au groupe}
         \PY{n}{g}\PY{o}{.}\PY{n}{groups}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}55}]:} \{'A': Int64Index([0, 3], dtype='int64'),
          'B': Int64Index([1, 4], dtype='int64'),
          'C': Int64Index([2, 5], dtype='int64')\}
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}56}]:} \PY{c+c1}{\PYZsh{} pour accéder directement au groupe, on peut utiliser get\PYZus{}group}
         \PY{n}{g}\PY{o}{.}\PY{n}{get\PYZus{}group}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{A}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}56}]:}   key  val1  val2
         0   A     0   100
         3   A     3   103
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}57}]:} \PY{c+c1}{\PYZsh{} on peut également filtrer un groupe par colonne}
         \PY{c+c1}{\PYZsh{} lors d\PYZsq{}une opération}
         \PY{n}{g}\PY{o}{.}\PY{n}{sum}\PY{p}{(}\PY{p}{)}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{val2}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}57}]:} key
         A    203
         B    205
         C    207
         Name: val2, dtype: int64
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}58}]:} \PY{c+c1}{\PYZsh{} ou directement sur l\PYZsq{}objet produit par groupby}
         \PY{n}{g}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{val2}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{o}{.}\PY{n}{sum}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}58}]:} key
         A    203
         B    205
         C    207
         Name: val2, dtype: int64
\end{Verbatim}
            
    On peut également itérer sur les groupes avec un boucle \texttt{for}
classique~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}59}]:} \PY{k+kn}{import} \PY{n+nn}{seaborn} \PY{k}{as} \PY{n+nn}{sns}
         \PY{c+c1}{\PYZsh{} on charge le fichier de données des pourboires}
         \PY{n}{tips} \PY{o}{=} \PY{n}{sns}\PY{o}{.}\PY{n}{load\PYZus{}dataset}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{tips}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} pour rappel}
         \PY{n}{tips}\PY{o}{.}\PY{n}{head}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}59}]:}    total\_bill   tip     sex smoker  day    time  size
         0       16.99  1.01  Female     No  Sun  Dinner     2
         1       10.34  1.66    Male     No  Sun  Dinner     3
         2       21.01  3.50    Male     No  Sun  Dinner     3
         3       23.68  3.31    Male     No  Sun  Dinner     2
         4       24.59  3.61  Female     No  Sun  Dinner     4
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}60}]:} \PY{c+c1}{\PYZsh{} on groupe le DataFrame par jours}
         \PY{n}{g} \PY{o}{=} \PY{n}{tips}\PY{o}{.}\PY{n}{groupby}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{day}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} on calcule la moyenne du pourboire par jour}
         \PY{k}{for} \PY{p}{(}\PY{n}{group}\PY{p}{,} \PY{n}{index}\PY{p}{)} \PY{o+ow}{in} \PY{n}{g}\PY{p}{:}
             \PY{n+nb}{print}\PY{p}{(}\PY{n}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{On }\PY{l+s+si}{\PYZob{}group\PYZcb{}}\PY{l+s+s2}{ the mean tip is }\PY{l+s+s2}{\PYZob{}}\PY{l+s+s2}{index[}\PY{l+s+s2}{\PYZsq{}}\PY{l+s+s2}{tip}\PY{l+s+s2}{\PYZsq{}}\PY{l+s+s2}{].mean():.3\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
On Thur the mean tip is 2.77
On Fri the mean tip is 2.73
On Sat the mean tip is 2.99
On Sun the mean tip is 3.26
\end{Verbatim}

    L'objet produit par \texttt{groupby} supporte ce que l'on appelle le
\emph{dispatch} de méthodes. Si une méthode n'est pas directement
définie sur l'objet produit par \texttt{groupby}, elle est appelée sur
chaque groupe (il faut donc qu'elle soit définie sur les
\texttt{DataFrame} ou les \texttt{Series}). Regardons cela~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}61}]:} \PY{c+c1}{\PYZsh{} on groupe par jour et on extrait uniquement la colonne \PYZsq{}total\PYZus{}bill\PYZsq{}}
         \PY{c+c1}{\PYZsh{} pour chaque groupe}
         \PY{n}{g} \PY{o}{=} \PY{n}{tips}\PY{o}{.}\PY{n}{groupby}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{day}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{total\PYZus{}bill}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}
         
         \PY{c+c1}{\PYZsh{} on demande à pandas d\PYZsq{}afficher les float avec seulement deux chiffres}
         \PY{c+c1}{\PYZsh{} après la virgule}
         \PY{n}{pd}\PY{o}{.}\PY{n}{set\PYZus{}option}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{display.float\PYZus{}format}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+si}{\PYZob{}:.2f\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{o}{.}\PY{n}{format}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} on appelle describe() sur g, mais elle n\PYZsq{}est pas définie sur cet objet,}
         \PY{c+c1}{\PYZsh{} elle va donc être appelée (dispatch) sur chaque groupe}
         \PY{n}{g}\PY{o}{.}\PY{n}{describe}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}61}]:}       count  mean  std  min   25\%   50\%   75\%   max
         day                                                
         Thur  62.00 17.68 7.89 7.51 12.44 16.20 20.16 43.11
         Fri   19.00 17.15 8.30 5.75 12.09 15.38 21.75 40.17
         Sat   87.00 20.44 9.48 3.07 13.91 18.24 24.74 50.81
         Sun   76.00 21.41 8.83 7.25 14.99 19.63 25.60 48.17
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}62}]:} \PY{c+c1}{\PYZsh{} Mais, il y a tout de même un grand nombre de méthodes}
         \PY{c+c1}{\PYZsh{} définies directement sur l\PYZsq{}objet produit par le groupby}
         
         \PY{n}{methods} \PY{o}{=} \PY{p}{[}\PY{n}{x} \PY{k}{for} \PY{n}{x} \PY{o+ow}{in} \PY{n+nb}{dir}\PY{p}{(}\PY{n}{g}\PY{p}{)} \PY{k}{if} \PY{o+ow}{not} \PY{n}{x}\PY{o}{.}\PY{n}{startswith}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZus{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{]}
         \PY{n}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Le type }\PY{l+s+s2}{\PYZob{}}\PY{l+s+s2}{type(g).\PYZus{}\PYZus{}name\PYZus{}\PYZus{}\PYZcb{} expose }\PY{l+s+s2}{\PYZob{}}\PY{l+s+s2}{len(methods)\PYZcb{} méthodes.}\PY{l+s+s2}{\PYZdq{}}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}62}]:} 'Le type SeriesGroupBy expose 68 méthodes.'
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}63}]:} \PY{c+c1}{\PYZsh{} profitons de la mise en page des dataframes}
         \PY{c+c1}{\PYZsh{} pour afficher ces méthodes sur plusieurs colonnes}
         \PY{c+c1}{\PYZsh{} on fait un peu de gymnastique}
         \PY{c+c1}{\PYZsh{} il y a d\PYZsq{}ailleurs sûrement plus simple..}
         \PY{n}{columns} \PY{o}{=} \PY{l+m+mi}{7}
         \PY{n}{nb\PYZus{}methods} \PY{o}{=} \PY{n+nb}{len}\PY{p}{(}\PY{n}{methods}\PY{p}{)}
         \PY{n}{nb\PYZus{}pad} \PY{o}{=} \PY{p}{(}\PY{n}{columns} \PY{o}{\PYZhy{}} \PY{n}{nb\PYZus{}methods} \PY{o}{\PYZpc{}} \PY{n}{columns}\PY{p}{)} \PY{o}{\PYZpc{}} \PY{n}{columns}
         
         \PY{n}{array} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{n}{methods} \PY{o}{+} \PY{n}{nb\PYZus{}pad} \PY{o}{*} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{)}\PY{o}{.}\PY{n}{reshape}\PY{p}{(}\PY{p}{(}\PY{n}{columns}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}64}]:} \PY{n}{pd}\PY{o}{.}\PY{n}{DataFrame}\PY{p}{(}\PY{n}{data}\PY{o}{=}\PY{n}{array}\PY{o}{.}\PY{n}{transpose}\PY{p}{(}\PY{p}{)}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}64}]:}            0          1          2                        3           4  \textbackslash{}
         0        agg   cumcount     fillna  is\_monotonic\_decreasing     ngroups   
         1  aggregate     cummax     filter  is\_monotonic\_increasing    nlargest   
         2        all     cummin      first                     last   nsmallest   
         3        any    cumprod  get\_group                      mad         nth   
         4      apply     cumsum     groups                      max     nunique   
         5   backfill   describe       head                     mean        ohlc   
         6      bfill       diff       hist                   median         pad   
         7       corr      dtype     idxmax                      min  pct\_change   
         8      count  expanding     idxmin                     ndim        pipe   
         9        cov      ffill    indices                   ngroup        plot   
         
                   5             6  
         0      prod           sum  
         1  quantile          tail  
         2      rank          take  
         3  resample     transform  
         4   rolling        tshift  
         5       sem        unique  
         6     shift  value\_counts  
         7      size           var  
         8      skew                
         9       std
\end{Verbatim}
            
    Nous allons regarder la méthode \texttt{aggregate} (dont l'alias est
\texttt{agg}). Cette méthode permet d'appliquer une fonction (ou liste
de fonctions) à chaque groupe avec la possibilité d'appliquer une
fonction à une colonne spécifique du groupe.

Une subtilité de \texttt{aggregate} est que l'on peut passer soit un
objet fonction, soit un nom de fonction sous forme d'une \texttt{str}.
Pour que l'utilisation du nom de la fonction marche, il faut que la
fonction soit définie sur l'objet produit par le \texttt{groupby} ou
qu'elle soit définie sur les groupes (donc avec dispatching).

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}65}]:} \PY{c+c1}{\PYZsh{} calculons la moyenne et la variance pour chaque groupe}
         \PY{c+c1}{\PYZsh{} et chaque colonne numérique}
         \PY{n}{tips}\PY{o}{.}\PY{n}{groupby}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{day}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{o}{.}\PY{n}{agg}\PY{p}{(}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{mean}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{std}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}65}]:}      total\_bill       tip      size     
                    mean  std mean  std mean  std
         day                                     
         Thur      17.68 7.89 2.77 1.24 2.45 1.07
         Fri       17.15 8.30 2.73 1.02 2.11 0.57
         Sat       20.44 9.48 2.99 1.63 2.52 0.82
         Sun       21.41 8.83 3.26 1.23 2.84 1.01
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}66}]:} \PY{c+c1}{\PYZsh{} de manière équivalente avec les objets fonctions}
         \PY{n}{tips}\PY{o}{.}\PY{n}{groupby}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{day}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{o}{.}\PY{n}{agg}\PY{p}{(}\PY{p}{[}\PY{n}{np}\PY{o}{.}\PY{n}{mean}\PY{p}{,} \PY{n}{np}\PY{o}{.}\PY{n}{std}\PY{p}{]}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}66}]:}      total\_bill       tip      size     
                    mean  std mean  std mean  std
         day                                     
         Thur      17.68 7.89 2.77 1.24 2.45 1.07
         Fri       17.15 8.30 2.73 1.02 2.11 0.57
         Sat       20.44 9.48 2.99 1.63 2.52 0.82
         Sun       21.41 8.83 3.26 1.23 2.84 1.01
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}67}]:} \PY{c+c1}{\PYZsh{} en appliquant une fonction différente pour chaque colonne,}
         \PY{c+c1}{\PYZsh{} on passe alors un dictionnaire qui a pour clef le nom de la}
         \PY{c+c1}{\PYZsh{} colonne et pour valeur la fonction à appliquer à cette colonne}
         \PY{n}{tips}\PY{o}{.}\PY{n}{groupby}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{day}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{o}{.}\PY{n}{agg}\PY{p}{(}\PY{p}{\PYZob{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{tip}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{n}{np}\PY{o}{.}\PY{n}{mean}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{total\PYZus{}bill}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{n}{np}\PY{o}{.}\PY{n}{std}\PY{p}{\PYZcb{}}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}67}]:}       tip  total\_bill
         day                  
         Thur 2.77        7.89
         Fri  2.73        8.30
         Sat  2.99        9.48
         Sun  3.26        8.83
\end{Verbatim}
            
    La méthode \texttt{filter} a pour but de filtrer les groupes en fonction
d'un critère. Mais attention, \texttt{filter} retourne \textbf{un sous
ensemble des données originales} dans lesquelles les éléments
appartenant aux groupes filtrés ont été enlevés.

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}68}]:} \PY{n}{d} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{DataFrame}\PY{p}{(}\PY{p}{\PYZob{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{key}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{n+nb}{list}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ABCABC}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{,} 
                           \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{val1}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{6}\PY{p}{)}\PY{p}{,}
                           \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{val2}\PY{l+s+s1}{\PYZsq{}} \PY{p}{:} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{100}\PY{p}{,} \PY{l+m+mi}{106}\PY{p}{)}\PY{p}{\PYZcb{}}\PY{p}{)}
         \PY{n}{d}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}68}]:}   key  val1  val2
         0   A     0   100
         1   B     1   101
         2   C     2   102
         3   A     3   103
         4   B     4   104
         5   C     5   105
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}69}]:} \PY{c+c1}{\PYZsh{} regardons la somme par groupe}
         \PY{n}{d}\PY{o}{.}\PY{n}{groupby}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{key}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{o}{.}\PY{n}{sum}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}69}]:}      val1  val2
         key            
         A       3   203
         B       5   205
         C       7   207
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}70}]:} \PY{c+c1}{\PYZsh{} maintenant gardons dans les données originales toutes les lignes}
         \PY{c+c1}{\PYZsh{} pour lesquelles la somme de leur groupe est supérieure à 3}
         \PY{c+c1}{\PYZsh{} (ici les groupes B et C)}
         \PY{n}{d}\PY{o}{.}\PY{n}{groupby}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{key}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{o}{.}\PY{n}{filter}\PY{p}{(}\PY{k}{lambda} \PY{n}{x}\PY{p}{:} \PY{n}{x}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{val1}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{o}{.}\PY{n}{sum}\PY{p}{(}\PY{p}{)} \PY{o}{\PYZgt{}} \PY{l+m+mi}{3}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}70}]:}   key  val1  val2
         1   B     1   101
         2   C     2   102
         4   B     4   104
         5   C     5   105
\end{Verbatim}
            
    La méthode \texttt{transform} a pour but de retourner \textbf{un sous
ensemble des données originales} dans lesquelles une fonction a été
appliquée par groupe. Un usage classique est de centrer des valeurs par
groupe, ou de remplacer les \texttt{NaN} d'un groupe par la valeur
moyenne du groupe.

Attention, \texttt{transform} ne doit pas faire de modifications en
place, sinon le résultat peut être faux. Faites donc bien attention de
ne pas appliquer des fonctions qui font des modications en place.

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}71}]:} \PY{n}{r} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{random}\PY{o}{.}\PY{n}{normal}\PY{p}{(}\PY{l+m+mf}{0.5}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{)}
         \PY{n}{d} \PY{o}{=} \PY{n}{pd}\PY{o}{.}\PY{n}{DataFrame}\PY{p}{(}\PY{p}{\PYZob{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{key}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{n+nb}{list}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ab}\PY{l+s+s1}{\PYZsq{}}\PY{o}{*}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{data}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{n}{r}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{data2}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{n}{r}\PY{o}{*}\PY{l+m+mi}{2}\PY{p}{\PYZcb{}}\PY{p}{)}
         \PY{n}{d}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}71}]:}   key  data  data2
         0   a  2.14   4.28
         1   b -2.02  -4.03
         2   a  1.34   2.69
         3   b -0.97  -1.94
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}72}]:} \PY{c+c1}{\PYZsh{} je groupe sur la colonne \PYZsq{}key\PYZsq{}}
         \PY{n}{g} \PY{o}{=} \PY{n}{d}\PY{o}{.}\PY{n}{groupby}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{key}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}73}]:} \PY{c+c1}{\PYZsh{} maintenant je centre chaque groupe par rapport à sa moyenne}
         \PY{n}{g}\PY{o}{.}\PY{n}{transform}\PY{p}{(}\PY{k}{lambda} \PY{n}{x}\PY{p}{:} \PY{n}{x} \PY{o}{\PYZhy{}} \PY{n}{x}\PY{o}{.}\PY{n}{mean}\PY{p}{(}\PY{p}{)}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}73}]:}    data  data2
         0  0.40   0.80
         1 -0.52  -1.05
         2 -0.40  -0.80
         3  0.52   1.05
\end{Verbatim}
            
    Notez que la colonne \texttt{key} a disparu, ce comportement est
expliqué ici~:

http://pandas.pydata.org/pandas-docs/stable/groupby.html\#automatic-exclusion-of-nuisance-columns

Pour aller plus loin sur \texttt{groupby} vous pouvez lire la
documentation~:

http://pandas.pydata.org/pandas-docs/stable/groupby.html

    \hypertarget{ruxe9organisation-des-indexes-avec-pivot}{%
\subsubsection{\texorpdfstring{Réorganisation des indexes avec
\texttt{pivot}}{Réorganisation des indexes avec pivot}}\label{ruxe9organisation-des-indexes-avec-pivot}}

    Un manière de voir la notion de pivot est de considérer qu'il s'agit
d'une extension de \texttt{groupy} à deux dimensions. Pour illustrer
cela, prenons un exemple en utilisant le jeu de données seaborn sur les
passagers du Titanic.

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}74}]:} \PY{n}{titanic} \PY{o}{=} \PY{n}{sns}\PY{o}{.}\PY{n}{load\PYZus{}dataset}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{titanic}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}75}]:} \PY{c+c1}{\PYZsh{} regardons le format de ce jeu de données}
         \PY{n}{titanic}\PY{o}{.}\PY{n}{head}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}75}]:}    survived  pclass     sex   age  sibsp  parch  fare embarked  class    who  \textbackslash{}
         0         0       3    male 22.00      1      0  7.25        S  Third    man   
         1         1       1  female 38.00      1      0 71.28        C  First  woman   
         2         1       3  female 26.00      0      0  7.92        S  Third  woman   
         3         1       1  female 35.00      1      0 53.10        S  First  woman   
         4         0       3    male 35.00      0      0  8.05        S  Third    man   
         
            adult\_male deck  embark\_town alive  alone  
         0        True  NaN  Southampton    no  False  
         1       False    C    Cherbourg   yes  False  
         2       False  NaN  Southampton   yes   True  
         3       False    C  Southampton   yes  False  
         4        True  NaN  Southampton    no   True
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}76}]:} \PY{c+c1}{\PYZsh{} regardons maintenant le taux de survie par classe et par sex}
         \PY{n}{titanic}\PY{o}{.}\PY{n}{pivot\PYZus{}table}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{survived}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{index}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{class}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{columns}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{sex}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}76}]:} sex     female  male
         class               
         First     0.97  0.37
         Second    0.92  0.16
         Third     0.50  0.14
\end{Verbatim}
            
    Je ne vais pas entrer plus dans le détail, mais vous voyez qu'il s'agit
d'un outil très puissant.

Pour aller plus loin, vous pouvez regarder la documentation officielle~:

http://pandas.pydata.org/pandas-docs/stable/reshaping.html

mais vous aurez des exemples beaucoup plus parlants en regardant ici :

https://github.com/jakevdp/PythonDataScienceHandbook/blob/master/notebooks/03.09-Pivot-Tables.ipynb


    % Add a bibliography block to the postdoc
    
    
    
